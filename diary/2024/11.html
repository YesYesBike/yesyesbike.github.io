<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>C, Perl, Linux</title>
	</head>
	<body>
		<h1>"When in doubt, use brute force" -Ken Thompson</h1>
		<hr>
		<p><a href="../../index.html">홈으로</a></p>
		<p><a href="../index.html">일기 목록</a></p>
		<p><a href="index.html">일기/2024년</a></p>
		<p><a href="10.html">&lt;- 10월</a></p>
		<br>
		<h2>2024/11/1</h2>
		<p>
11월을 맞이하여 새로운 페이지로 이사하였다.
하루하루 나이를 먹어가는 느낌이 그리 좋지는 않지만 달리 어쩌겠는가?
오늘도 어제와 다름없이 보잘것없는 코드를 짜고 있다.
		</p>

		<p>
오늘의 사소한 깨달음: Bash에 Parameter Expansion이라는 기능이 있다. 하지만 유의할 점이 있다.
이 기능은 POSIX 표준이 아니어서 dash나 ksh에서는 작동하지 않을 수 있다.
{one, two, three}나 {1..10}은 알고 있었지만 이걸 파일 확장자에 쓸 생각은 못했다.
(사실 위 둘은 엄밀히 말하자면 Brace Expansion이긴 하다.)
Parameter Expansion은 변수 안의 부분문자열을 다룰 수 있게 한다.
man page를 읽어 보면 수많은 항목들이 나열되어 있다.
그 중에서 확장자 일괄 변환에 쓰이는 게 하나 있다. 바로 % 기호이다.
%는 맨 끝에 해당하는 문자열을 없앤다. 즉 $lol이 "asdf"일 때 ${lol%df}는 "as"가 된다.
참고로 % 뒤의 문자열이 맨 끝에 오지 않으면 무시된다.
이를 이용해서 파일 확장자를 일괄 변환할 수 있다.
물론 파일 확장자뿐 아니라 다양한 곳에 쓰일 수 있겠지만 지금은 생각이 잘 안 난다.
<br>결론: for f in *.py; do mv ${f%.py}.rb; done -&gt; Python 파일을 Ruby로 변환
<br>참고: Bash(1)의 Parameter Expansion 항목
		</p>

		<br>

		<h2>2024/11/7</h2>
		<p>
거의 일주일 만에 일기를 다시 쓰게 되었다. 한동안 무슨 일이 있었나 싶겠지만 <strong>실제</strong> 아무 일 없었다.
		</p>

		<p>
이번 주는 Plan 9이라는 신세계를 체험하느라 밤새 잠을 잘 못 이뤘다.
Plan 9은 벨 연구소의 유닉스 개발자들이 처음부터 새로 만든 운영체제이다. 왜인지는 몰라도 잘 알려저 있지 않다.
온갖 기능이 덕지덕지 붙어있는 GNU 산 유틸리티와 달리 최소한의 기능만을 갖춘 게 인상적이다.
예를 들어 cat 명령어는 옵션이 아예 없고 오로지 표준 입출력 기능만을 제공한다.
다른 특징으로 그 어느 리눅스 배포판에서도 찾아 볼 수 없는 독특한 그래픽 환경이 있다.
rio라는 독자적인 윈도우 시스템과 그 위에서 돌아가는 텍스트 편집기 acme와 sam은 그야말로 감탄을 자아낸다.
마우스로 작동하는 그래픽 환경이지만 요즘 흔한 GUI보다 더 혁신적이다.
텍스트를 어떤 마우스 버튼으로 누르냐에 따라 다른 동작을 한다.
문서를 편집하면서 쉘 명령어를 입력하고 그걸 가운데 버튼으로 드래그하면 명령이 실행된다.
acme와 sam에는 툴바가 있는데 근본적으로는 텍스트 편집 창과 다르지 않다.
즉 사용자가 원하는 대로 글자를 입력해 사용자 지정 명령어를 툴바에 고정할 수 있다.
sam은 Structured Regular Expressions라고 불리는 다층적인 정규표현식을 지원한다.
이 또한 다른 편집기에서는 찾아보기 힘든 특징인데 이에 대해서는 나중에 다루겠다.
		</p>
		
		<p>
sam은 ed 기반의 라인 편집기와 풀스크린 편집기의 기능을 동시에 쓸 수 있다.
vi 계열의 편집기는 ex 모드로 라인 편집기와 비주얼 편집기를 오갈 수 있지만 둘을 동시에 쓸 수는 없다.
vim의 command-line window가 불완전하게 흉내내는 것 말고 다른 편집기에서는 이런 기능을 찾아볼 수 없다.
이런 혁신적인 기능을 갖췄지만 세 가지 제한 사항 때문에 사용을 포기할 수밖에 없었다.
하나는 폰트 문제이다. 글씨가 너무 작아 도저히 읽을 수가 없다. 사실 소스 코드에 포함된 폰트를 바꾸면 될 듯하지만 아직 해보지 않았다.
일관성 없는 명령어 동작도 한몫 한다. 같은 'g' 명령어도 ed와 sam의 동작이 서로 다르다.
g/re라고 입력하면 ed에서는 re를 갖고 있는 줄을 모두 출력하지만 sam에서는 문서 전체를 출력한다(왜?).
사실 결정적인 이유는 따로 있다. 바로 마우스다.
이제는 vi 계열 편집기가 아니면 오히려 불편할 정도로 적응이 된 마당에 마우스를 써야 한다면 정말 고통스러울 것이다.
그런 고난을 감내하면서까지 sam에 매달리고 싶지는 않다.
		</p>

		<p>
vim이 정말로 강력하고 유용한 편집기는 맞지만 한계가 분명 존재한다.
내가 원하는 기능의 95%는 갖추었지만 역시 아쉬운 부분이 있다.
파일 끝에서 커서가 정중앙에 맞춰지지 않는 것은 온갖 설정과 플러그인으로도 해결이 안 되었다.
하지만 다른 편집기를 생각해보자. 이 기능을 제공하는 다른 편집기가 하나라도 있을까?
아마도 찾으면 나올지도 모르지만 현재 내가 누리고 있는 기능을 갖추지 못했을 확률이 높다.
물론 이맥스인지 뭐시긴지는 뭐든지 다 할 수 있을 테지만 그걸 쓰고 싶지는 않다.
vim에서 sam의 기능을 구현하려고 온갖 삽질을 해왔지만 아직 플러그인을 만들만한 실력은 되지 않아서 성공은 거두지 못하고 있다.
vis는 vim과 sam의 기능을 둘 다 갖췄다고 하지만 자잘한 버그가 많다.
예를 들어서 입력 모드에서 노멀 모드로 전환할 때 커서 위치가 변하지 않는 문제가 있다.
어쩌면 설계 상 의도된 걸지도 모르겠으나 그런 게 더 악질이다.
		</p>

		<p>
ed 같은 라인 편집기의 장점과 vi 같은 비주얼 편집기의 장점을 모두 갖춘 편집기가 있을까?
앞에서 말한 sam조차 불편한 점이 여러 군데 있다. 아직까지는 vim보다 편한 편집기는 못 찾았다.
사실 vim이 아니라 Neovim을 쓰고 있지만 기능 상으로는 대동소이하다.
sam처럼 명령창과 텍스트 화면을 동시에 보여주고(원할 때마다 껐다 켰다 할 수 있어야 한다) 둘 사이를 자유롭게 오갈 수 있는 편집기를 원한다.
다만 터미널 인터페이스 위에서 동작해야 한다. 이 점은 절대 타협할 수 없다. 결국 ed나 ex/vi, vim로 돌아오게 된다.
ex와 vi는 동일한 프로세스에서 동작하지만 둘 중 하나만 써야하고 동시에는 못 쓴다. 결국 불편한 ex 대신 vi만 계속 쓰게 된다.
오늘날에 라인 편집기는 사장되었지만 비주얼 편집기만으로는 하기 어려운 일을 해낼 수 있다.
vi 같은 에디터는 일시적으로 라인 편집기를 지원하지만 내 생각에는 좀 더 쓰기 편리해질 필요가 있다.
명령어를 입력할 때마다 :를 일일이 눌려야 한다면 매우 귀찮을 것이다.
만약 텍스트 에디터를 새로 만든다면 ex와 vi의 기능을 적절히 잘 통합하는 데에 중점을 둬야 할 듯하다.
그리고 ed(plan9, BSD, GNU)와 ex(nex)의 서로 조금씩 다른 명령어를 모두 아울러야 할 것이다.
레이아웃은 거칠게 말해서 대략 gdb의 tui와 비슷할 듯하다. 요즘은 tui로 표현할 수 있는 범위가 넓어져서 내 생각도 구현할 수 있을 것이다.
		</p>

		<p>
모든 프로그램이 그렇지만 텍스트 편집기를 개발할 때 주의할 점이 있다. 이는 매우 중요해서 따로 이름까지 붙었다.
최소 놀람의 법칙(Principle of Least Astonishment)이라고도 불리는 이 법칙은 기존 관습에서 너무 많은 걸 바꾸지 말 것을 요구한다.
편집기(특히나 vim)를 기본 설정으로 쓰는 사람이 드물지만 자신의 입맛에 맞지 않는다고 기본 설정에서부터 갈아 엎으려고 하면 안 된다.
vim조차 vi에 대한 backward compatibility를 지원한다.
그렇지만 요즘 vi의 불편함(입력 모드에서 기존 글자를 지우지 못하는 것이 대표적이다)을 그대로 감내하는 사람은 드물기 때문에 거기까지는 갈 필요 없다.
그래서 비주얼 모드(이 용어는 vi와 vim에서 서로 다른 개념을 지칭한다. vi에서는 글자가 화면에 '보이는' vi모드를 말하고 vim에서는 글자를 선택하는 모드를 말한다. 그 중에서 나는 vi 쪽을 따른다)에서의 동작은 vim의 기본 동작을 구현하는 게 나을 것이다.
하지만 명령어 모드에서의 동작은 철저히 ed의 편을 들어 간소화할 것이다.
사실 기능의 구현 범위에 대해 많은 고민이 있다. vim의 수많은 기능을 집어넣기에는 한계가 있다. 게다가 그 중에서 자주 쓰는 기능은 적다.
Debian 계열에서 기본적으로 제공하는 vim-tiny가 일단은 기준점이 될 듯하다.
그렇지만 이는 나중에 할 고민이고 지금 당장은 여러 텍스트 에디터(ed, ex/vi, vim)의 코드를 이해하고 분석하는 게 급선무이다.
정말 힘든 작업이 될 것이다...
		</p>
		
		<br>

		<h2>2024/11/9</h2>
		<p>
라인 편집기의 불편한 점에 대해 곰곰이 생각해 봤고 두 가지 점을 찾아냈다.
하나는 줄 안에서 수정할 때 수정할 문자열을 지정해야 한다는 것이고
다른 하나는 명령어를 입력하기까지 결과를 알 수 없는 것이다.
결국 이는 즉각적인 피드백이 없다는 점 하나로 수렴한다.
한 번에 한 줄밖에 볼 수 없다는 문제도 있지만 이는 부차적이다.
명령어를 적절히 잘 사용하면 큰 불편함 없이 쓸 수 있다.
첫 번째 문제는 라인 편집기에 본질적으로 커서가 없는 데에서 발생한다.
요즘 편집기에서 이런 광경은 상상조차 할 수 없지만 오히려 옛날에는 요즘 편집기를 상상할 수조차 없었다.
라인 편집기에서는 수정할 단어에 커서를 가져다 대는 대신에 정규 표현식으로 해당 문자열의 패턴을 지정한다.
패턴이 간단하면 그나마 덜 불편하겠지만 까다로운 곳에 있다면 단어 하나 고치는 데에 1분 넘게 쓸 수도 있다.
두 번째 문제도 상당히 심각하다. 만약 수정할 패턴을 찾아서 입력했다 해도 잘못 고칠 수 있다.
이를 되돌리고 다시 입력하는 데에 상당히 많은 시간이 소모된다.
		</p>

		<p>
라인 편집기가 아주 불편한 건 맞지만 그 점이 오히려 장점이 되기도 한다.
라인 편집기는 모든 동작을 문자열로 정의할 수 있다.
이는 vi에도 해당하는 이야기이지만 vi에서의 키 입력을 텍스트로 일일이 분석하기 어렵다.
vim에서 한번 매크로가 저장된 레지스터를 출력해보라. 이를 읽고 제대로 이해하기 매우 힘들 것이다.
마우스까지 출동한다면 키 입력만으로 행동 전체를 정의하기란 불가능에 가까워진다.
반면 라인 편집기에서는 명령어만 있기 때문에 키 입력을 스크립트로 나타내기 더 쉽다.
이런 장점만 갖춘 프로그램인 sed는 요즘도 널리 쓰인다.
		</p>

		<p>
비록 라인 편집기를 옹호하고는 있지만 지금 이 글은 vim으로 쓰고 있다.
한글 입력 때문에 어쩔 수 없이 그러고 있다. ed에는 범위 지정 필터 기능이 없다.
즉 범위를 지정해서 ! 명령어로 해당 범위를 파이프로 보낸 다음 쉘 명령어의 출력을 받을 수 없다.
사실 ex에는 이런 기능이 있기는 하다. 하지만 현재 ed에 대한 글을 쓰고 있기 때문에 차마 ex를 쓸 수는 없다.
		</p>

		<p>
20%가 전체의 80%를 생산한다는 파레토 법칙이 있다. awk에도 비슷한 법칙이 적용된다.
<strong>실제</strong> awk는 기초적인 명령어만 알아도 웬만한 곳에서 요긴하게 써먹을 수 있다.
"awk '{ print $1 }' file" 이 명령어가 가장 기초적인 형태이다.
file의 첫 번째 열만 출력하는 이 명령어는 이 자체만으로 큰 변형 없이 다양하게 쓸 수 있다.
거기다 산술 연산까지 지원하니 grep이나 sed의 한계를 넘어선 작업을 하는 데에 큰 도움이 된다.
awk의 철학은 C언어의 구문에서 구체적인 구현에 대한 걱정 없이 원하는 기능을 구현하는 것이다.
많은 점이 C언어와 비슷하지만 따로 변수를 선언하지 않고 대입만으로 바로 사용할 수 있다. 이 점에서는 Shell과 유사하다.
		</p>

		<br>

		<h2>2024/11/10</h2>
		<p>
라인 편집기와 비주얼 편집기의 차이는 장기(또는 체스 또는 바둑)와 비디오 게임의 차이인 것 같다.
라인 편집기는 잘만 쓰면 최소한의 타이핑으로 많은 일을 할 수 있다.
하지만 타자 수가 준다고 해서 시간이 적게 걸리는 건 아니다. 오히려 한 글자 한 글자 신중하게 입력해야 한다.
이는 타자기를 쓰던 과거의 상황을 반영했다고 볼 수 있다. 타자기는 스크린보다 글자 출력 속도가 말이 안 되게 느리다.
그래서 당시에는 되도록이면 글자를 적게 입력하려고 했다. C언어 문법의 단순함과 ed의 명령어가 모두 한 글자인 걸 생각해보라.
장기에서도 한 수를 두는 데에 길게는 몇 분씩이나 걸리기 때문에 이런 점이 비슷하다고 느꼈다.
		</p>

		<p>
반면 vi로 문서를 작성하면 때로는 비디오 게임을 하는 듯한 기분이 든다.
그도 그럴 게 vi에서는 키보드를 이용해 실시간으로 커서의 위치를 여러 곳으로 움직일 수 있다.
원하는 위치로 커서를 움직일 때 움직임을 최소화하는 것도 중요하지만 시간이 적게 걸리는 게 더 중요하다.
예를 들어 나는 여러 단어를 움직일 때 단어 수를 세서 (n)w처럼 하는 것보다 얻어 걸릴 때까지 w를 연타하는 걸 더 선호한다.
단어를 일일이 세는 데에 시간이 더 걸리기 때문이다.
vi 이용자들은 아마 시간과 타자 수 둘 중 하나를 포기해야 한다면 후자를 택할 것이다. 하지만 장기적으로 보면 타자 수를 줄이는 것도 중요하다.
왜냐하면 처음에는 시간이 오래 걸리는 특정 작업이 나중에 숙달되면 딱히 의식하지 않아도 빨리 수행할 수 있기 때문이다.
요즘 나는 입력 모드에서 단어를 지울 때 백스페이스를 꾹 누르기보다 C-w 키를 누르려고 노력하고 있다.
		</p>

		<p>
시간과 타자 수 어느 쪽에 중점을 두는지 간에 궁극적인 목표는 둘 다 줄이는 것이다. 그리고 그 사이에서 균형을 맞추는 것이다.
하지만 나는 아직도 의문이 든다. 과연 줄 사이를 오갈 때 jk를 꾹 눌러야 하는가? 아니면 (n)jk라고 쳐야 하는가?
		</p>
	</body>
</html>
