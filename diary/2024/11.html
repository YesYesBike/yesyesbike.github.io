<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>C, Perl, Linux</title>
	</head>
	<body>
		<h1>"When in doubt, use brute force" -Ken Thompson</h1>
		<hr>
		<p><a href="../../index.html">홈으로</a></p>
		<p><a href="../index.html">일기 목록</a></p>
		<p><a href="index.html">일기/2024년</a></p>
		<p><a href="10.html">&lt;- 10월</a></p>
		<p><a href="12.html">12월 -&gt;</a></p>
		<br>
		<h2>2024/11/1</h2>
		<p>
11월을 맞이하여 새로운 페이지로 이사하였다.
하루하루 나이를 먹어가는 느낌이 그리 좋지는 않지만 달리 어쩌겠는가?
오늘도 어제와 다름없이 보잘것없는 코드를 짜고 있다.
		</p>

		<p>
오늘의 사소한 깨달음: Bash에 Parameter Expansion이라는 기능이 있다. 하지만 유의할 점이 있다.
이 기능은 POSIX 표준이 아니어서 dash나 ksh에서는 작동하지 않을 수 있다.
{one, two, three}나 {1..10}은 알고 있었지만 이걸 파일 확장자에 쓸 생각은 못했다.
(사실 위 둘은 엄밀히 말하자면 Brace Expansion이긴 하다.)
Parameter Expansion은 변수 안의 부분문자열을 다룰 수 있게 한다.
man page를 읽어 보면 수많은 항목들이 나열되어 있다.
그 중에서 확장자 일괄 변환에 쓰이는 게 하나 있다. 바로 % 기호이다.
%는 맨 끝에 해당하는 문자열을 없앤다. 즉 $lol이 "asdf"일 때 ${lol%df}는 "as"가 된다.
참고로 % 뒤의 문자열이 맨 끝에 오지 않으면 무시된다.
이를 이용해서 파일 확장자를 일괄 변환할 수 있다.
물론 파일 확장자뿐 아니라 다양한 곳에 쓰일 수 있겠지만 지금은 생각이 잘 안 난다.
<br>결론: for f in *.py; do mv ${f%.py}.rb; done -&gt; Python 파일을 Ruby로 변환
<br>참고: Bash(1)의 Parameter Expansion 항목
		</p>

		<br>

		<h2>2024/11/7</h2>
		<p>
거의 일주일 만에 일기를 다시 쓰게 되었다. 한동안 무슨 일이 있었나 싶겠지만 <strong>실제</strong> 아무 일 없었다.
		</p>

		<p>
이번 주는 Plan 9이라는 신세계를 체험하느라 밤새 잠을 잘 못 이뤘다.
Plan 9은 벨 연구소의 유닉스 개발자들이 처음부터 새로 만든 운영체제이다. 왜인지는 몰라도 잘 알려저 있지 않다.
온갖 기능이 덕지덕지 붙어있는 GNU 산 유틸리티와 달리 최소한의 기능만을 갖춘 게 인상적이다.
예를 들어 cat 명령어는 옵션이 아예 없고 오로지 표준 입출력 기능만을 제공한다.
다른 특징으로 그 어느 리눅스 배포판에서도 찾아 볼 수 없는 독특한 그래픽 환경이 있다.
rio라는 독자적인 윈도우 시스템과 그 위에서 돌아가는 텍스트 편집기 acme와 sam은 그야말로 감탄을 자아낸다.
마우스로 작동하는 그래픽 환경이지만 요즘 흔한 GUI보다 더 혁신적이다.
텍스트를 어떤 마우스 버튼으로 누르냐에 따라 다른 동작을 한다.
문서를 편집하면서 쉘 명령어를 입력하고 그걸 가운데 버튼으로 드래그하면 명령이 실행된다.
acme와 sam에는 툴바가 있는데 근본적으로는 텍스트 편집 창과 다르지 않다.
즉 사용자가 원하는 대로 글자를 입력해 사용자 지정 명령어를 툴바에 고정할 수 있다.
sam은 Structured Regular Expressions라고 불리는 다층적인 정규표현식을 지원한다.
이 또한 다른 편집기에서는 찾아보기 힘든 특징인데 이에 대해서는 나중에 다루겠다.
		</p>
		
		<p>
sam은 ed 기반의 라인 편집기와 풀스크린 편집기의 기능을 동시에 쓸 수 있다.
vi 계열의 편집기는 ex 모드로 라인 편집기와 비주얼 편집기를 오갈 수 있지만 둘을 동시에 쓸 수는 없다.
vim의 command-line window가 불완전하게 흉내내는 것 말고 다른 편집기에서는 이런 기능을 찾아볼 수 없다.
이런 혁신적인 기능을 갖췄지만 세 가지 제한 사항 때문에 사용을 포기할 수밖에 없었다.
하나는 폰트 문제이다. 글씨가 너무 작아 도저히 읽을 수가 없다. 사실 소스 코드에 포함된 폰트를 바꾸면 될 듯하지만 아직 해보지 않았다.
일관성 없는 명령어 동작도 한몫 한다. 같은 'g' 명령어도 ed와 sam의 동작이 서로 다르다.
g/re라고 입력하면 ed에서는 re를 갖고 있는 줄을 모두 출력하지만 sam에서는 문서 전체를 출력한다(왜?).
사실 결정적인 이유는 따로 있다. 바로 마우스다.
이제는 vi 계열 편집기가 아니면 오히려 불편할 정도로 적응이 된 마당에 마우스를 써야 한다면 정말 고통스러울 것이다.
그런 고난을 감내하면서까지 sam에 매달리고 싶지는 않다.
		</p>

		<p>
vim이 정말로 강력하고 유용한 편집기는 맞지만 한계가 분명 존재한다.
내가 원하는 기능의 95%는 갖추었지만 역시 아쉬운 부분이 있다.
파일 끝에서 커서가 정중앙에 맞춰지지 않는 것은 온갖 설정과 플러그인으로도 해결이 안 되었다.
하지만 다른 편집기를 생각해보자. 이 기능을 제공하는 다른 편집기가 하나라도 있을까?
아마도 찾으면 나올지도 모르지만 현재 내가 누리고 있는 기능을 갖추지 못했을 확률이 높다.
물론 이맥스인지 뭐시긴지는 뭐든지 다 할 수 있을 테지만 그걸 쓰고 싶지는 않다.
vim에서 sam의 기능을 구현하려고 온갖 삽질을 해왔지만 아직 플러그인을 만들만한 실력은 되지 않아서 성공은 거두지 못하고 있다.
vis는 vim과 sam의 기능을 둘 다 갖췄다고 하지만 자잘한 버그가 많다.
예를 들어서 입력 모드에서 노멀 모드로 전환할 때 커서 위치가 변하지 않는 문제가 있다.
어쩌면 설계 상 의도된 걸지도 모르겠으나 그런 게 더 악질이다.
		</p>

		<p>
ed 같은 라인 편집기의 장점과 vi 같은 비주얼 편집기의 장점을 모두 갖춘 편집기가 있을까?
앞에서 말한 sam조차 불편한 점이 여러 군데 있다. 아직까지는 vim보다 편한 편집기는 못 찾았다.
사실 vim이 아니라 Neovim을 쓰고 있지만 기능 상으로는 대동소이하다.
sam처럼 명령창과 텍스트 화면을 동시에 보여주고(원할 때마다 껐다 켰다 할 수 있어야 한다) 둘 사이를 자유롭게 오갈 수 있는 편집기를 원한다.
다만 터미널 인터페이스 위에서 동작해야 한다. 이 점은 절대 타협할 수 없다. 결국 ed나 ex/vi, vim로 돌아오게 된다.
ex와 vi는 동일한 프로세스에서 동작하지만 둘 중 하나만 써야하고 동시에는 못 쓴다. 결국 불편한 ex 대신 vi만 계속 쓰게 된다.
오늘날에 라인 편집기는 사장되었지만 비주얼 편집기만으로는 하기 어려운 일을 해낼 수 있다.
vi 같은 에디터는 일시적으로 라인 편집기를 지원하지만 내 생각에는 좀 더 쓰기 편리해질 필요가 있다.
명령어를 입력할 때마다 :를 일일이 눌려야 한다면 매우 귀찮을 것이다.
만약 텍스트 에디터를 새로 만든다면 ex와 vi의 기능을 적절히 잘 통합하는 데에 중점을 둬야 할 듯하다.
그리고 ed(plan9, BSD, GNU)와 ex(nex)의 서로 조금씩 다른 명령어를 모두 아울러야 할 것이다.
레이아웃은 거칠게 말해서 대략 gdb의 tui와 비슷할 듯하다. 요즘은 tui로 표현할 수 있는 범위가 넓어져서 내 생각도 구현할 수 있을 것이다.
		</p>

		<p>
모든 프로그램이 그렇지만 텍스트 편집기를 개발할 때 주의할 점이 있다. 이는 매우 중요해서 따로 이름까지 붙었다.
최소 놀람의 법칙(Principle of Least Astonishment)이라고도 불리는 이 법칙은 기존 관습에서 너무 많은 걸 바꾸지 말 것을 요구한다.
편집기(특히나 vim)를 기본 설정으로 쓰는 사람이 드물지만 자신의 입맛에 맞지 않는다고 기본 설정에서부터 갈아 엎으려고 하면 안 된다.
vim조차 vi에 대한 backward compatibility를 지원한다.
그렇지만 요즘 vi의 불편함(입력 모드에서 기존 글자를 지우지 못하는 것이 대표적이다)을 그대로 감내하는 사람은 드물기 때문에 거기까지는 갈 필요 없다.
그래서 비주얼 모드(이 용어는 vi와 vim에서 서로 다른 개념을 지칭한다. vi에서는 글자가 화면에 '보이는' vi모드를 말하고 vim에서는 글자를 선택하는 모드를 말한다. 그 중에서 나는 vi 쪽을 따른다)에서의 동작은 vim의 기본 동작을 구현하는 게 나을 것이다.
하지만 명령어 모드에서의 동작은 철저히 ed의 편을 들어 간소화할 것이다.
사실 기능의 구현 범위에 대해 많은 고민이 있다. vim의 수많은 기능을 집어넣기에는 한계가 있다. 게다가 그 중에서 자주 쓰는 기능은 적다.
Debian 계열에서 기본적으로 제공하는 vim-tiny가 일단은 기준점이 될 듯하다.
그렇지만 이는 나중에 할 고민이고 지금 당장은 여러 텍스트 에디터(ed, ex/vi, vim)의 코드를 이해하고 분석하는 게 급선무이다.
정말 힘든 작업이 될 것이다...
		</p>
		
		<br>

		<h2>2024/11/9</h2>
		<p>
라인 편집기의 불편한 점에 대해 곰곰이 생각해 봤고 두 가지 점을 찾아냈다.
하나는 줄 안에서 수정할 때 수정할 문자열을 지정해야 한다는 것이고
다른 하나는 명령어를 입력하기까지 결과를 알 수 없는 것이다.
결국 이는 즉각적인 피드백이 없다는 점 하나로 수렴한다.
한 번에 한 줄밖에 볼 수 없다는 문제도 있지만 이는 부차적이다.
명령어를 적절히 잘 사용하면 큰 불편함 없이 쓸 수 있다.
첫 번째 문제는 라인 편집기에 본질적으로 커서가 없는 데에서 발생한다.
요즘 편집기에서 이런 광경은 상상조차 할 수 없지만 오히려 옛날에는 요즘 편집기를 상상할 수조차 없었다.
라인 편집기에서는 수정할 단어에 커서를 가져다 대는 대신에 정규 표현식으로 해당 문자열의 패턴을 지정한다.
패턴이 간단하면 그나마 덜 불편하겠지만 까다로운 곳에 있다면 단어 하나 고치는 데에 1분 넘게 쓸 수도 있다.
두 번째 문제도 상당히 심각하다. 만약 수정할 패턴을 찾아서 입력했다 해도 잘못 고칠 수 있다.
이를 되돌리고 다시 입력하는 데에 상당히 많은 시간이 소모된다.
		</p>

		<p>
라인 편집기가 아주 불편한 건 맞지만 그 점이 오히려 장점이 되기도 한다.
라인 편집기는 모든 동작을 문자열로 정의할 수 있다.
이는 vi에도 해당하는 이야기이지만 vi에서의 키 입력을 텍스트로 일일이 분석하기 어렵다.
vim에서 한번 매크로가 저장된 레지스터를 출력해보라. 이를 읽고 제대로 이해하기 매우 힘들 것이다.
마우스까지 출동한다면 키 입력만으로 행동 전체를 정의하기란 불가능에 가까워진다.
반면 라인 편집기에서는 명령어만 있기 때문에 키 입력을 스크립트로 나타내기 더 쉽다.
이런 장점만 갖춘 프로그램인 sed는 요즘도 널리 쓰인다.
		</p>

		<p>
비록 라인 편집기를 옹호하고는 있지만 지금 이 글은 vim으로 쓰고 있다.
한글 입력 때문에 어쩔 수 없이 그러고 있다. ed에는 범위 지정 필터 기능이 없다.
즉 범위를 지정해서 ! 명령어로 해당 범위를 파이프로 보낸 다음 쉘 명령어의 출력을 받을 수 없다.
사실 ex에는 이런 기능이 있기는 하다. 하지만 현재 ed에 대한 글을 쓰고 있기 때문에 차마 ex를 쓸 수는 없다.
		</p>

		<p>
20%가 전체의 80%를 생산한다는 파레토 법칙이 있다. awk에도 비슷한 법칙이 적용된다.
<strong>실제</strong> awk는 기초적인 명령어만 알아도 웬만한 곳에서 요긴하게 써먹을 수 있다.
"awk '{ print $1 }' file" 이 명령어가 가장 기초적인 형태이다.
file의 첫 번째 열만 출력하는 이 명령어는 이 자체만으로 큰 변형 없이 다양하게 쓸 수 있다.
거기다 산술 연산까지 지원하니 grep이나 sed의 한계를 넘어선 작업을 하는 데에 큰 도움이 된다.
awk의 철학은 C언어의 구문에서 구체적인 구현에 대한 걱정 없이 원하는 기능을 구현하는 것이다.
많은 점이 C언어와 비슷하지만 따로 변수를 선언하지 않고 대입만으로 바로 사용할 수 있다. 이 점에서는 Shell과 유사하다.
		</p>

		<br>

		<h2>2024/11/10</h2>
		<p>
라인 편집기와 비주얼 편집기의 차이는 장기(또는 체스 또는 바둑)와 비디오 게임의 차이인 것 같다.
라인 편집기는 잘만 쓰면 최소한의 타이핑으로 많은 일을 할 수 있다.
하지만 타자 수가 준다고 해서 시간이 적게 걸리는 건 아니다. 오히려 한 글자 한 글자 신중하게 입력해야 한다.
이는 타자기를 쓰던 과거의 상황을 반영했다고 볼 수 있다. 타자기는 스크린보다 글자 출력 속도가 말이 안 되게 느리다.
그래서 당시에는 되도록이면 글자를 적게 입력하려고 했다. C언어 문법의 단순함과 ed의 명령어가 모두 한 글자임을 생각해보라.
장기에서도 한 수를 두는 데에 길게는 몇 분씩이나 걸리기 때문에 이런 점이 비슷하다고 느꼈다.
		</p>

		<p>
반면 vi로 문서를 작성하면 때로는 비디오 게임을 하는 듯한 기분이 든다.
그도 그럴 게 vi에서는 키보드를 이용해 실시간으로 커서의 위치를 여러 곳으로 움직일 수 있다.
원하는 위치로 커서를 움직일 때 움직임을 최소화하는 것도 중요하지만 시간이 적게 걸리는 게 더 중요하다.
예를 들어 나는 여러 단어를 움직일 때 단어 수를 세서 (n)w처럼 하는 것보다 얻어 걸릴 때까지 w를 연타하는 걸 더 선호한다.
단어를 일일이 세는 데에 시간이 더 걸리기 때문이다.
vi 이용자들은 아마 시간과 타자 수 둘 중 하나를 포기해야 한다면 후자를 택할 것이다. 하지만 장기적으로 보면 타자 수를 줄이는 것도 중요하다.
왜냐하면 처음에는 시간이 오래 걸리는 특정 작업이 나중에 숙달되면 딱히 의식하지 않아도 빨리 수행할 수 있기 때문이다.
요즘 나는 입력 모드에서 단어를 지울 때 백스페이스를 꾹 누르기보다 C-w 키를 누르려고 노력하고 있다.
		</p>

		<p>
시간과 타자 수 어느 쪽에 중점을 두는지 간에 궁극적인 목표는 둘 다 줄이는 것이다. 그리고 그 사이에서 균형을 맞추는 것이다.
하지만 나는 아직도 의문이 든다. 과연 줄 사이를 오갈 때 jk를 꾹 눌러야 하는가? 아니면 (n)jk라고 쳐야 하는가?
		</p>
		
		<br>

		<h2>2024/11/13</h2>
		<p>
지금 이 시대가 프로그래밍 공부하기에는 가장 축복받은 시기인 듯하다.
당장 웹 브라우저에 모르는 걸 검색하기만 하면 전문 지식이 없더라도 금방 해결책을 찾을 수 있을 것이다.
IT 업계 특성 상 인터넷이나 웹 상에 문서가 가장 잘 정리되어있고 자유 소프트웨어 운동의 영향 때문인지 지식을 공유하는 것에 꽤나 관대하다.
그렇지만 일종의 회의감도 느껴진다. 지금부터 할 말은 업계에 발을 담그지 않은 비전공자 아마추어의 한탄 내지 망상일 테니 적절히 걸러 듣길 바란다.
지난 일 년 동안 Vim을 거쳐 리눅스와 C를 공부하다 보니 내가 배우는 게 비주류 지식임을 차츰 알게 되었다.
인공지능이니 빅데이터니 하는 여러 응용 컴퓨터 분야가 부상하고 관련 서적도 많이 나온다.
리액트니 뭐시기니 앵귤러 뭐시기니 쿠버네티스, 도커, AWS 등등... 수많은 프레임워크가 범람한다.
예전에 겪었던 자바+이클립스의 저주 탓인지는 몰라도 내게는 이런 게 두통을 불러올 뿐이다.
하지만 유닉스 관련으로 돌아서면 이런 골칫거리는 싹 사라진다. 잘 쓰여진 C언어 코드를 보면 마음이 편안해진다.
C Programming Language의 예제 코드 하나 하나가 간결함과 명확함의 정수를 보여준다.
물론 여기에도 그 나름의 어려움이 있다. 인터페이스는 간단하지만 구현까지 간단하지는 않다.
C언어를 배웠다고 해서 곧바로 커널 소스 코드를 이해할 수 없는 것처럼 유닉스의 작동 원리를 이해하려면 다른 분야의 공부도 필요하다.
컴퓨터 구조, 운영체제 등등 관련 분야 지식도 필요하고 시스템 콜이 뭐가 있는지도 알아야 하고 그리고 남의 소스 코드를 이해할 수 있어야 한다.
코드를 이해하는 게 공부에 있어서 가장 중요한 궁극적인 목표라 할 수 있다.
기존의 코드를 읽고 이해하지 않는 한 내가 짜는 모든 코드는 바퀴의 재발명일 뿐이다.
		</p>

		<p>
요즘 프로그램들은 하나 같이 쓸데 없이 기능이 많다. 유닉스의 지향점과 정반대에 있는 소프트웨어가 즐비해 있다.
이미 있는 프로그램들을 잘 조합하기보다는 하나의 덩치 큰 괴물을 새로 만들어버린다.
이들은 지나치게 비대하지만 이미 하나로 태어난 시점에서 사용자가 몸집을 줄일 방법은 없다.
소위 말하는 IDE의 아이디어는 이미 오래 전 쉘에서 구현되었지만 사람들은 그걸로는 만족을 못하는 듯하다.
웹 브라우저는 필요악 그 자체가 되어버렸다. CSS, 자바스크립트가 웹 브라우저를 무겁게 하는 주범인데 이들을 비활성화하면 할 수 있는 일이 80% 줄어버린다(팔레트 뭐시기).
자신에게 필요한 만큼의 프로그램만 깔 수도 없다. 윈도우는... 말을 말자.
내가 앞에서 말한 궁극적인 목표도 여기에 관련이 있다. 바로 자신이 쓰는 프로그램이 어떻게 돌아가는지 이해하는 것이다.
내가 이루고자 하는 게 무엇인가? 필요한 기능만 갖추는 것. 그리고 쓰더라도 제대로 알고 쓰는 것. 별 것 아닌 것처럼 들리더라도 이루기는 상당히 어렵다.
		</p>

		<p>
요즘 ed의 <a href="https://9p.io/sources/plan9/sys/src/cmd/ed.c">소스 코드</a>를 읽으며 디버거를 붙여서 분석하고 있다. 이렇게 말은 하고 있지만 아직까지는 진척이 없다.
한 줄 한 줄 변수에 있는 값을 확인하는데 이 변수들이 어디에 쓰이는지 감을 못 잡고 있다. 전역 변수가 너무나 많은 데다가 이에 대한 설명이 전혀 없다.
예를 들어 init() 함수 내에 등장하는 subnewa, anymarks, iblock, oblock, ichanged, dot, dol, zero 등이 모두 전역변수이다.
그런데 아직까지도 subnewa가 뭔지, anymarks는 어디서 뭘 하는데 쓰이는지 모르겠다.
그나마 dot랑 dol은 각각 현재 줄, 마지막 줄인 걸 알아냈다.
그런데 이게 왜 int형 포인터인지, 여기에 저장되는 값이 뭔지 전혀 모르겠다.
zero는 main 함수에서(진짜 메인 함수가 아니라 wrapper인 게 밝혀졌다) nlall+5에다 sizeof(int*)을 곱한 값만큼을 할당받는데
왜 int형 포인터의 크기를 곱하는지(zero는 int형 포인터다), 왜 하필 5를 더하는지, nlall의 값이 왜 128인지 모르겠다.<br>
		</p>

		<p>
다들 알겠지만 ed는 유명한 텍스트 편집기 중에서 가장 오래된 프로그램으로 요즘 편집기에 비하면 상당히 간단하다.
그런데도 소스 코드를 이해하는 데에 상당히 애를 먹고 있다. 이게 무엇을 의미하는가?
ed보다 복잡한 프로그램은 널리고 널렸다. 그렇지만 이들을 아무렇지도 않게 쓰는 게 어딘가 이상하지 않은가?
과연 어디서부터 잘못된 걸까. 최초에 컴퓨터를 사용한 사람들은 그 컴퓨터를 설계하거나 적어도 작동 원리를 알았을 것이다.
하지만 요즘은 어떤가? 컴퓨터를 제대로 이해하지 못해도 쓸 수 있는 세상이 왔지만 지나치게 위험한 장난감을 손에 넣은 게 아닐까?
물론 사람들에게서 컴퓨터를 모조리 압수해야 한다는 말을 하려는 게 아니다. 다만 일종의 부조리를 폭로하려고 하는 것이다.
마이크로프로세서와 PC를 비교해보자. 둘의 성능 차이는 압도적이다.
AMD64 프로세서는 1초에 수십억 번 하는 부동소수점 연산도 MCU에게는 버겁거나 불가능하다.
그래서 MCU는 PC에서 간단하게 돌아가는 프로그램도 돌릴 수 없거나 별도의 최적화가 필요하다.
그렇지만 고성능 CPU를 갖춘 PC에서 printf로 Hello World를 출력하는 사람이
MCU에서 UART로 똑같은 일을 사람보다 컴퓨터를 더 잘 이해하는 걸까? 그건 아닐 것이다.
stdio로 메시지를 출력하는 것은  운영체제, glibc가 알아서 해주니 사용자는 신경 쓸 게 적다.
하지만 MCU에서 메시지를 출력하려면 전자회로 같은 하드웨어 지식은 둘째 치고서라도 어디에 얼마만큼 전압을 줄지 등등을 직접 설계해야 한다.
공정하게 말해서 아무런 배경지식이 없는 사람에게 똑같이 따라하라고만 한다면 MCU 쪽이 훨씬 더 오래 걸릴 것이다.
		</p>

		<p>
마찬가지로 옛날 프로그래머와 요즘 프로그래머를 비교해보자.
온갖 프레임워크와 라이브러리의 안개 속에서 허덕이는 프로그래머가 
과연 기계어에서 어셈블러를 만들고 어셈블리어에서 컴파일러를 만든 프로그래머보다 컴퓨터를 잘 이해한다고 볼 수 있을까?
당연히 최초의 컴파일러는 매우 보잘것없고 비효율적이었을 것이다. 하지만 적어도 그들은 유에서 무를 창조해냈다.
요즘 프로그래머는 옛날 프로그래머보다 더 열등하다고 말하려 하는 게 아니다.
다만 지식이 너무나 파편화되어서 본질을 이해하기가 훨씬 더 힘들어졌다는 말을 하고 싶었다.
과거의 유산을 물려받았지만 그걸 어떻게 다뤄야할지 모르는 게 안타까운 것이다.
내가 하고 싶은 말은 이제 끝났다.
저수준에 대한 전반적인 관심이 늘었으면 좋겠다는 말을 이렇게 장황하게 늘어뜨렸다.
		</p>

		<br>

		<h2>2024/11/14</h2>
		<p>
POSIX에 관한 좋은 자료를 제공하는 <a href="https://pubs.opengroup.org/onlinepubs/9799919799/">사이트</a>를 찾았다. 심지어 공신력도 있다.
그럴 수밖에 없는 게 POSIX 공식 사이트이기 때문이다. 여기서 POSIX 표준에 대한 가장 명확한 정보를 얻을 수 있다.
리눅스는 POSIX를 잘 준수하지만 여러 비표준 API를 가지고 있다. epoll, clearenv 등이 그러하다.
이러한 확장 기능은 특정 운영체제에 특화된 기능을 백분 활용할 수 있게 하기 때문에 어느 정도는 필요하다.
POSIX는 애초에 인터페이스만 다루지 구현 자체는 각 운영체제에게 일임한다.
man page의 8번 섹션은 시스템 관리 관련 내용을 다루는데 POSIX는 여기에 관여하지 않는다.
이처럼 인터페이스와 구현이 구분되어 있기 때문에 리눅스와 다른 유닉스 계열 운영체제는 비슷한 듯하면서도 많이 다른 부분이 있다.
리눅스에 익숙하다고 곧바로 BSD까지 능숙하게 다룰 수는 없다. 별도의 학습이 필요하다.
맨 처음으로 다가오는 장벽이 바로 셸의 차이다. 리눅스("GNU"/Linux)는 Bash로 통일되어 있지만 다른 유닉스 계열 OS는 각기 다른 셸을 쓴다.
기본 설정으로 FreeBSD는 tcsh을 쓰고 OpenBSD는 pdksh를 쓴다. Mac OS는 zsh을 쓴다.
이들은 POSIX를 준수하지만 세부 기능의 차이가 존재한다.
이전에 말했던 Brace Expansion이나 Parameter Expansion 외에도 Herestring, $RANDOM 등은 모두 Bash 전용 기능이다.
더 자세한 내용은 Bashism에 대해 잘 정리한 <a href="https://mywiki.wooledge.org/Bashism">사이트</a>에서 확인하길 바란다.
이 때문에 Bash를 쓰다 다른 셸을 쓰려 할 때 크고 작은 문제가 생긴다.
		</p>

		<p>
이식성 따위 알 게 뭐야 하는 마음가짐도 어찌 보면 꽤 괜찮을 수 있다. 귀찮은 일을 줄일 수 있을 테니 말이다.
<strong>실제</strong> 윈도우가 데스크탑 시장을 장악했을 때 POSIX의 도움은 거의 받지 않았을 것이다.
윈도우는 자체적으로도 대성했다. Visual Studio가 오랫동안 C99 표준조차 제대로 지원하지 않았는데도 적어도 한국에서는 위세를 떨쳤으니 말이다.
악명 높은 fflush(stdin)의 망령이 아직도 돌아다니는 걸 보면 그 폐해가 얼마나 큰지 가늠할 수 있을 것이다.
현재 윈도우의 존재 의의는 PC 게임 구동이 가장 크다. 윈도우 말고 다른 데서 돌아가는 게임을 찾기 힘들 지경이니 말 다 했다.
한때는 일어나서 잘 때까지 게임만 하는 게 일상이었지만 이제는 더 이상 게임을 하지 않으니 전혀 필요 없다.
하지만 아직까지도 디스크에서 윈도우를 지워버리지 못하고 있다. 바로 공인 뭐시기 때문이다.
리눅스에서 금융 서비스를 이용하는 상황을 가정해보자(너무 소리 내서 웃진 말자).
일단 그 인증서가 리눅스에서 제대로 지낼 수 있을 것 같지는 않다. 여러 보안 프로그램이 함께 있어야 하기 때문이다.
내가 아는 바로는 그들은 ELF 형식을 갖추고 있지 않아서 리눅스에서는 이들을 실행 파일로 보지 않을 것이다.
Shebang도 없는 텍스트 파일을 어떻게 실행하겠는가? 그래서 부랴부랴 Bash가 출동하지만 전혀 알아들을 수 없다!
결국 영영 실행되지 못한 채 쓸쓸히 사라질 것이다. 이런 부조리한 현실 때문에 수십 기가바이트나 되는 디스크 공간을 윈도우에 내주고 있다.
		</p>

		<br>

		<h2>2024/11/15</h2>
		<p>
Postel의 법칙이 있다. 자신에게는 엄격하게, 받아들일 때는 너그러워지라는 이 법칙은 꽤나 많은 걸 시사한다.
하지만 지식의 전파와 수용에 있어서도 똑같이 적용할 수 있을까?
그렇진 않을 것이다(애초에 이 법칙은 인터페이스 설계에 대한 원칙이어서 지나친 확대 해석을 해서는 안 될 것이다).
잘못된 정보의 폐해는 웹 상에 만연하는 온갖 개소리로 쉽게 알 수 있다.
개소리를 내뱉는 것은 쉽지만 거기에 일일이 조목조목 반박하기는 쉽지 않다.
마치 쓰레기를 쌓이는 속도가 치우는 속도보다 훨씬 빠른 것과 같다.
구글이나 네이버에서 검색만 하면 쉽게 정보를 얻을 수 있지만 과연 얼마나 믿을 수 있을까?
뭐시기 위키는 의외로 제대로 된 정보도 있지만 여기만 참고해서 얻는 건 잡지식뿐이다.
사실 나조차 이런 말을 할 처지는 아니다. 그렇기에 오히려 반성하는 마음으로 이런 글을 쓴다.
여기가 비록 일기장이고 나 말고 아무도 읽을 사람이 없겠지만 나중에 읽으면 얼굴을 붉힐 곳이 한두 군데가 아닐 것이다.
		</p>

		<p>
그래서 잘못된 정보를 최소한으로 하려고 여러 방법을 시도하고 있다.
그 중 하나는 믿을 만한 출처를 제시하는 것이다. 전에 말한 POSIX 표준 문서는 명성에 편승하여 인용해도 내게 책임을 묻지 않을 것이다.
다른 하나는 다양한 곳에서 같은 주제를 다룬 글을 읽는 것이다.
Trusting Trust에 대한 <a href="https://dwheeler.com/trusting-trust/dissertation/html/wheeler-trusting-trust-ddc.html">글 하나</a>를 읽고 있다.
이걸 읽게 된 경위는 Ken Thompson의 유명한 글 Reflections on Trusting Trust였다.
이 글은 고작 3페이지밖에 안 되지만 사이버 보안의 본질적인 문제를 세상에 알린 꽤나 가치 있는 글이다.
처음 읽을 때는 뭔 말인가 하고 넘어갔으나 관련 소스 코드를 시연한 <a href="https://research.swtch.com/nih">이 글</a>을 읽고 문제의 심각성을 알게 되었다.
하지만 이 글만 읽어서는 도무지 성에 차지 않아서 맨 처음에 언급한 글도 읽게 된 것이다.
학술 문서를 읽는 데에 익숙하지 않았지만 차츰 읽으면서 느낀 게 있다.
1)참고 문헌 목록이 매우 길다. 2)선행 연구에 대한 조사가 철저하다.
물론 여태껏 논문을 쓴 적도 없고 앞으로도 쓸 일이 없는지라 이렇게까지 형식에 맞출 생각은 없지만 자료를 조사하고 검증하는 자세만큼은 배울 만하다.
<strong>실제</strong> 이 논문에 대한 <a href="https://dwheeler.com/trusting-trust/">소개 글</a>만 읽어도 배가 터질 지경이다.
잘못된 정보를 퍼뜨리지 않는 것은 제대로 된 정보를 받아들이는 것보다 몇 배나 되는 노력이 필요한 법이다.
		</p>
		
		<br>

		<h2>2024/11/19</h2>
		<p>
(비전공자이자 업계인도 아닌) 내 생각에 개발자로서 실력을 늘리려면 매뉴얼을 읽는 게 가장 중요한 것 같다.
예전에 말한 것처럼 혼자서 코딩한다고 해서 실력이 좋아질 수도 있지만 아무것도 배우지 않고서는 불가능하다.
프로그래밍 언어를 배울 때 아무런 교재나 자료 없이 붓다 중점으로 자신만을 등불로 삼아 나아간다면 도로아미타불일 것이다.
결국 뭔가를 보고 배워야 하는데 검증된 자료가 아니라면 먼 길을 돌아갈 게 뻔하다.
웹 검색이나 챗 뭐시기가 급한 불을 끄는 데에 도움이 되는 건 맞지만 이런 지식은 단편화가 심하고 질도 천차만별이다.
책을 읽는 게 더 나을지도 모르겠다. 이도 책마다 다르긴 하지만 적어도 단편적인 정보에서 그치지 않고 전체적인 그림을 파악할 수 있게 된다.
입문할 때 무슨 책을 읽어야 하는가? 쉬운 책을 읽어야 하는가, 아니면 조금 어렵더라도 정석적인 책을 읽어야 하는가?
언젠간 어려운 책도 읽어야 한다고는 확실하게 말할 수 있다.
궁극적으로는 자신이 직접 매뉴얼을 찾아가면서 공부해야 하지만 스스로 그럴 능력을 갖추기 전까지는 검증된 책으로 공부하는 게 낫다.
		</p>

		<br>

		<h2>2024/11/22</h2>
		<p>
오늘날 C언어는 자바나 파이썬, 자바스크립트 등등의 언어보다 인기가 없다.
C언어는 원하는 기능을 구현하는 데에 이르기까지 너무나 많은 시간이 필요하다.
코딩 시간과 학습 난이도 두 측면에서 학습자들을 괴롭히기 때문에 이를 못 견디는 사람들이 빠져나간다.
<strong>실제</strong> C언어가 다른 언어보다 더 낮은 수준을 다루다 보니 일일이 신경써야 할 게 많다.
그래서 코드 길이가 길어지고 이는 곧 개발 기간과 직결된다.
다른 언어에서는 몇 줄이면 되는 기능 하나를 구현하는 데에도 수많은 노력을 쏟아부어야 한다.
게다가 C언어는 결코 배우기 쉬운 언어가 아니다.
문법은 간단하지만 곳곳에 함정이 자리잡고 있어서 틈만 나면 버그가 나기 십상이다.
C언어 문법을 안다고 해서 바로 원하는 프로그램을 짤 수 있는 것도 아니다.
C언어 교재 한 권을 다 읽고나서 독자들은 보통 이렇게 생각할 것이다. "그래서 이걸로 뭘 할 수 있는거지?" 하고 말이다.
C언어의 꽃인 포인터도 배우고 구조체, 전처리기, 연결 리스트까지 다 배웠는데도 어디다 써먹어야 할지는 감을 잡기 힘들 것이다.
이런 문제 때문에 수많은 사람들이 C언어의 참맛을 깨우치기도 전에 다른 분야로 자리를 뜨는 비극이 이어진다.
		</p>

		<p>
먼저 말해두고 싶은 게 있다. C언어가 비록 위대하기는 하지만 만능은 아니다.
C언어로는 소프트웨어 수준에서 뭐든지 구현할 수 있지만 뭘 하든지 간에 가시밭길을 걸을 것이다.
그런데도 C언어가 꼭 필요한 분야가 있다. 커널, 시스템, 임베디드 프로그래밍 분야가 이에 속한다.
이들은 할 수 있는 한 가장 낮은 수준에서 최대한의 안정성과 성능을 이끌어 내는 임무를 가진다.
운영체제는 모든 프로그램 중에서 가장 똑똑하고 효율적이고 견고하게 동작해야 한다.
시스템 프로그램은 그 위에서 유저 레벨 내 저수준의 동작을 책임진다.
임베디드 분야에서는 최소한의 비용으로 최선의 결과를 내야 한다.
C++, Go, Rust 같은 언어에서도 비슷한 시도가 있지만 여전히 C언어가 가장 많이 쓰인다.
이들은 각각 높은 추상화, 가비지 컬렉터, 컴파일 타임 내 변수 수명 검사 같은 새로운 기능을 갖췄지만 C를 대체하지는 못하고 있다.
C언어로 이룬 수많은 업적을 위 셋 언어가 아직 뛰어넘지 못했기 때문이지 않나 싶다.
순수하게 C++/Go/Rust만으로 이루어진 커널은 아직 상상하기 어렵다.
		</p>

		<p>
중간에 얘기가 옆으로 새어버린 듯하다. 이왕 샌 김에 한 마디 덧붙이겠다.
아무리 고수준의 언어에서 프로그래밍한다 해도 컴퓨팅 환경의 기반은 변하지 않았다.
C를 대체한다느니 같은 소리를 아무리 열심히 지껄여봤자 리눅스 커널의 99%는 여전히 C언어로 되어있다.
예나 지금이나 CPU-메모리-I/O 구조는 근본적으로 변하지 않았다.
양자 컴퓨터 뭐시기가 나와서 폰노이만 구조 기반의 패러다임을 완전히 뒤엎지 않는 이상 C언어는 건재할 것이다.
		</p>
		
		<br>

		<h2>2024/11/23</h2>
		<p>
dup2() 함수를 배우고 있다. <a href="11_dup.txt">1,2번 두 구문</a>은 같은 일을 한다.
dup2() 함수는 dup()로 file descriptor(fd)를 redirection을 할 때 기존 fd를 일일이 close()해야 했던 번거로움을 해소하기 위해 생겼다.
사실 귀찮음보다는 race condition 때문이 더 컸다.
close()와 dup() 사이에 다른 스레드에서 fd 번호를 채갈 가능성이 있다.
원자성을 보장하기 위해 두 과정을 하나의 시스템 콜로 합친 것이 dup2()이다.
dup2()는 두 fd를 인자로 받는다. 왼쪽은 oldfd이고 오른쪽은 newfd로 불린다. 
Synopsis를 읽고선 oldfd에 해당하는 fd를 newfd로 대체한다고 생각하기 쉽지만 완전히 반대다.
newfd에 해당하는 fd를 먼저 닫은 다음 oldfd와 똑같은 fd를 가리키는 새로운 fd 값을 리턴한다.
지금 이렇게 정리했으니 망정이지 안 그랬으면 한참을 헤맬 뻔했다.
		</p>

		<p>
옛날 언젠가 유닉스 철학과 그에 반하는 현대 소프트웨어에 대해 속마음을 늘어놨었다.
하나의 일만 잘하려고 하는 게 아니라 너무 많은 일을 하나의 프로그램으로 처리하려는 이 현상에 대해 안타까움을 표했다.
일을 시키는 사람과 실제로 프로그램을 만드는 사람 사이의 입장이 일치하지 않아서 이런 일이 벌어지는 듯하다.
앞서 여러 번 강조했듯이 나는 업계에 종사하지 않으며 완전한 아마추어이다. 그러므로 실제로 무슨 일이 벌어지는가에 대한 지식은 전혀 없다.
결국 웹을 뒤져서 나온 정보에 의존할 수밖에 없으니 정말 안타깝다. 결국 이것도 하나의 망상에 불과한 것이다.
SI 업계가 내가 말한 문제점의 끝판왕인 걸로 보인다. SI 기업은 다른 기업이나 정부 기관에서 일거리를 얻어와 제작과 유지보수를 하는 외주 업체이다.
여기서부터 문제의 조짐이 드러난다. 이들은 결국 하청 업체인 것이다.
이런 프로그램을 짠 사람도 위에서 시키니 어쩔 수 없이 그렇게 짠 것이다.
사회 문제에서 멀어지려고 해도 현실이 이러니 어쩔 수 없다.
취미로서의 코딩은 재밌지만 그걸로 밥벌이를 하는 걸 상상하면 입맛이 뚝 떨어진다.
		<p>

		</p>
1960년대에 MIT에서 해커주의가 발흥했고 여러 과정을 거쳐서 지금까지도 그 기세가 이어지고 있다.
그 원동력은 그 누가 시켜서 생긴 게 아니라 자발적인 참여에서 비롯한 것이다.
최근 들어 진정으로 하고 싶은 일이 뭔지를 깨달았지만 현실은 그리 녹록지 않다.
오래 전에 버려두었던 해커로서의 야망을 다시금 불태우고 있지만 배워야 할 게 너무 많다.
제대로 공부하는 방법은 깨달았지만(매뉴얼) 갈 길이 너무 멀다.
그렇지만 마냥 안 좋은 일만 있는 건 아니다.
예전부터 공부했다면 어땠을까 하는 후회가 있지만 오히려 그때에는 사소한 위기도 대처하지 못했을 수 있다.
그때에는 지금보다 인내심이 부족했을 테니(지금이라고 크게 나아진 건 아니지만) 아마 금방 때려쳤을 가능성이 420% 정도 될 것이다.
또한 작업 환경이 윈도우였을 테니 탐구심에 큰 제약이 걸렸을 것이다.
지금처럼 유닉스의 참맛을 깨닫지 못했을 테니 아마 완전히 다른 길을 걸어갔을 것이다.
공부할 시간도 모자른 참에 이런 뻘소리를 몇 시간에 걸쳐 적었으니 그야말로 시간 낭비이다.
		</p>

		<br>

		<h2>2024/11/24</h2>
		<p>
C언어를 막 배웠다면 뭘 더 배워야 할까? 자료구조, 알고리즘, 운영체제, 컴퓨터구조 등등이 있다.
어차피 배워서 안 좋은 건 전혀 없다. 그렇지만 무엇을 우선으로 배워야 하는가?
그러려면 자신의 흥미가 어디에 가 있는지 파악해야 한다.
나 자신에 대해 말해보겠다. 나는 현재 UNIX 시스템 프로그래밍, 그 중에서도 POSIX API를 하나하나 익히는 데에 중점을 두고 있다.
이걸 배우는 데에 여러 이유가 있다. 1) C언어 문법만 배워서는 짤 수 없는, 시스템을 좀더 세밀하게 제어하는 프로그램을 짜기 위해서.
2) 자동화(날먹) 스크립트를 짤 때 시스템 관련 지식이 필요하기 때문에. 3) 3번은 아직 없다.
		</p>

		<p>
첫 번째 이유부터 설명해보겠다. 다들 알다시피 vi는 C언어로 쓰여졌다. 그런데 C언어를 배웠다고 바로 vi 같은 프로그램을 짤 수 있는 건 아니다.
C언어로 어떻게 vi 같은 프로그램을 짤 수 있을지 생각해보자.
C언어 문법에서는 터미널 화면을 풀스크린으로 제어할 방법을 알려주지 않는다. 과연 어떻게 이를 해결할 것인가?
vi에서 &lt;C-d&gt;나 &lt;C-c&gt; 같은 제어문자를 입력해도 여전히 멀쩡히 돌아간다. 이를 어떻게 구현했을까?
이런저런 질문에 대한 해답이 기본적으로 시스템 그 자체를 이해하는 데에 있다.<br>
두 번째 이유도 일맥상통한다. 지금은 C언어를 중점으로 공부하고 있지만 맨 처음 리눅스에서 프로그래밍을 배웠을 때는 쉘 스크립트를 공부했다.
쉘 스크립트랑 C언어가 언어 구조와 설계 목적이 다르기 때문에 동일 선상에 놓을 수 없지만 상당히 비슷한 점이 있다.
쉘에서 무슨 명령어를 입력하든지 간에 특정 시스템 콜을 호출한다(물론 예외는 있겠지만 지금은 안 떠오른다).
예를 들어서 tee나 cat 명령어는 기본적으로 open(), read(), write(), close()를 사용한다.
쉘 스크립트를 짜는 것은 거칠게 말해서 C언어로 시스템 프로그램을 짜는 것과 동일하다.
쉘 스크립트 쪽이 짜는 데에 시간이 더 적게 걸리는 게 다르다.
상상 속에서만 가능한 걸 실현하기 위해서는 쉘 문법 자체도 중요하지만 시스템 구조<del>(그리고 수많은 명령어)</del>를 알아야 한다.
		</p>

		<p>
컴퓨터 분야의 지식은 서로 매우 밀접한 관계에 있다. 즉 하나를 알면 다른 하나를 더 쉽게 배울 수 있다.
그리고 이들이 서로 다른 방식으로 하나의 목표를 추구하는 걸 알 수 있다(Harder, Better, Faster, Stronger).
이는 이미 깨우친 사람들에게는 매우 큰 이점이지만 구도자들에게는 크나큰 난점이다. 이들은 깨달음에 이르기까지 수많은 걸 배우고 익혀야 한다.
큰 그림과 세부적인 디테일을 모두 파악하는 게 매우 어렵기 때문에 맨 처음에는 너무 지엽적인 내용에 매몰되지 않는 게 좋다.
비록 지금은 시스템 API에 중점을 두고 있지만 운영체제나 컴퓨터 구조도 함께 조금씩 공부하고 있다.
여기서 배우는 지식이 API를 이해하는 데에도 큰 도움이 된다.
구체적인 예시를 하나 들어보겠다. 프로세스의 메모리는 크게 텍스트, 데이터, 스택, 힙 영역으로 나뉜다.
이 중에서 스택과 힙은 런타임에 경계가 변한다. brk()나 sbrk()는 이 중에서 힙 영역의 경계를 설정한다(POSIX에서는 웬만하면 이 둘을 쓰지 말라고 당부했다).
malloc()이나 free() 함수를 호출하면 결과적으로는 이들을 호출하게 된다(strace로 확인한 결과 내 컴퓨터에서는 brk()를 호출했으나 운영체제에 따라 다를 수 있다).
만약 가상 메모리, MMU 같은 존재를 전혀 모르고 네 가지 메모리 영역이 어떻게 다른지 모른다면 위 시스템 콜도 이해하기 더 힘들어질 것이다.
운영체제론과 컴퓨터 구조론에서 관련된 지식을 배울 수 있다.
		</p>

		<p>
그리고 둘 사이의 관계도 앞서 말한 바와 같다. 어쩔 때에는 범위가 겹쳐서 지금 어느 쪽을 공부하고 있는지 헷갈릴 때가 있다.
목차를 펼쳐보면 컴퓨터 구조론은 CPU에서 시작해 주메모리, 캐시 메모리, I/O 장치 순으로 되어 있다.
운영체제론은 프로세스 관리, 메모리 관리, 입출력 장치 관리 순으로 되어 있다.
이 중에서 소프트웨어로 제어할 수 없는 캐시 메모리를 제외하면 각각 일대일로 대응하는 걸 알 수 있다.
미묘한 차이는 분명 존재한다. 컴퓨터 구조론은 완전한 하드웨어 영역부터 소프트웨어 쪽으로는 어셈블리어까지만 다룬다.
반면 운영체제는 좀 더 소프트웨어 쪽에 치중되어 있다.
물론 둘은 엄연히 다른 분야이다. 하지만 이 둘을 따로 분리해서 생각할 필요는 전혀 없다.
비록 운영체제가 소프트웨어를 다루지만 하드웨어와 밀접하게 관련되어 있기 때문에 하드웨어에 대한 이해 없이는 공부하기 어려울 것이다.
반대로 얘기해서 둘을 함께 공부하면 따로 배울 때보다 더 쉽게 익힐 수 있다(논리적으로 참은 아닐지라도 그냥 넘어가자).
여기에 자료구조와 알고리즘을 양념으로 곁들이면 환상적인 콤비를 이룬다. 하지만 아직 이들은 후순위에 있다.
몇 달 전에 이진 트리까지 배우고 그냥 내버려 두고 있다.
		</p>

		<p>
이런 데에는 다 이유가 있다.
완성된 코드를 최적화할 때 자료구조와 알고리즘은 빛을 발한다.
하지만 완성하기도 전에 최적화를 하려고 한다면 빠져나갈 수 없는 고리에 갇히게 된다.
완성본이 있어야 거기에 대한 피드백으로 개선을 하든지 말든지 하는데 아무것도 없으면 말짱 꽝이다.
이런 종류의 최적화가 얼마만큼의 성능 향상으로 이어질지 아무도 알 수 없다. 기준점이 없는데 어떻게 비교를 할 것인가?
운이 없다면 시간 낭비에 그칠 뿐 아니라 버그를 유발할 수도 있다.
Premature Optimization을 만악의 근원으로 비유한 Donald Knuth 교수의 말은 상기할 가치가 있다.
이런 저런 자료구조와 알고리즘을 구현하는 건 좋은 연습이다.
그렇지만 가장 우선적인 목표는 바로 프로그램 자체를 완성하는 것이다. 차후에 갈아 엎더라도 말이다.
내가 짜는 프로그램은 처리 규모가 작은 간단한 프로그램이기 때문에 Big-O Notation에서 n에 해당하는 수는 매우 작다.
프로그램을 짜고 난 뒤에는 리팩토링 뭐시기의 일환으로 코드를 정리하기는 하지만 필요하지 않다면 자료구조를 바꾸지 않는다.
나중에 성능이 중요한 프로그램을 짜게 될 테지만 아직은 때가 아니다...
		</p>

		<h2>2024/11/25</h2>
		<p>
유닉스 철학에 심취한 사람이라면 누구나 읽어야 하는 문서를 하나 소개하겠다. 바로 UNIX 7판 매뉴얼이다.
그런데 왜 하필이면 다른 버전도 아니고 7판인가?
Volume 2에 유명한 The UNIX Time-Sharing System뿐 아니라 ed, troff, bc, dc, make, m4, lex, yacc, sed, awk 등의 유틸리티를 간략하게 소개하는 글들이 수록되어 있기 때문이다.
이들의 분량은 각각 길어봤자 30쪽 정도뿐이지만 질로 따지면 웹 상에 돌아다니는 그 어떤 튜토리얼보다 훌륭하다.
이 글만 읽어도 바로 실전에 써먹을 수 있을 만큼 내용도 알차다.
몇 주 전에 make 소개 글을 읽고 경악한 일이 있었다.
<a href="11_make.txt">이 파일</a>에서 알 수 있듯이 더 짧은 코드로 똑같은 일을 할 수 있다.
추가 옵션을 붙인다면 1번처럼 해야겠지만 이것만 해도 크나큰 충격이었다.
그런데 웹 그 어느 곳에서도 이런 걸 알려주는 글은 하나도 없었다.
다른 분야도 그렇겠지만 프로그래밍도 어디서 배우느냐가 제일 중요한 것 같다.
		</p>

		<br>

		<h2>2024/11/26</h2>
		<p>
객체지향 프로그래밍 철학에서 딱 하나 배울 점이라면 바로 인터페이스와 구현의 분리이다.
이 둘을 완전히 분리함으로써 일종의 모듈화를 이루게 되고 전체를 고칠 때보다 더 수월하게 유지보수할 수 있다.
C언어에서 캡슐화는 꽤 쉽게 해낼 수 있다.
두 소스 코드가 있을 때 하나에는 인터페이스를 담은 헤더만 포함시키고 나머지 하나에 구현을 담으면 된다.
이러면 구현을 담은 소스 코드를 다른 걸로 교체해도 여전히 잘 작동한다.
하지만 상속이나 다형성은 굉장히 세심한 트릭이 필요하다.
다들 알겠지만 C언어에는 클래스나 메서드라는 개념이 없어 구조체와 함수 포인터로 모든 걸 해결해야 한다.
상속은 부모에 해당하는 구조체를 자식에 그대로 포함할지, 아니면 포인터 형태로 포함할지의 문제가 있다.
전자를 택한다면 부모의 속성을 필요로 하는 함수를 쓸 때 부모의 타입으로 포인터를 캐스팅한 다음에 넘겨야 한다.
그냥 부모의 포인터를 포함한다면 부모가 아닌 자식을 매개변수로 받는 똑같은 함수를 새로 만들어야 한다.
매크로를 쓸 수도 있겠지만 아직 그 정도 실력까지는 되지 않아서 잘 모르겠다. 어느 쪽이든 번거로운 건 마찬가지이다.
다형성은 더 큰 문제이다.
OOP에 특화된 C++를 놔두고 굳이 C에서 이런 짓거리를 할 필요는 없다고 본다.
		</p>
	</body>
</html>
