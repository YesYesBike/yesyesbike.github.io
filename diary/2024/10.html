<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>C, Perl, Linux</title>
	</head>
	<body>
		<h1>"8진수는 Octal이지만 Octover는 10월이다.<br>
			10진수는 Decimal이지만 December는 12월이다." -미상</h1>
		<hr>
		<p><a href="../../index.html">홈으로</a></p>
		<p><a href="../index.html">일기 목록</a></p>
		<p><a href="index.html">일기/2024년</a></p>
		<br>
		<h2>2024/10/11</h2>
		<p>
깃헙 페이지에 홈페이지를 게시하고 나서 메인 페이지를 손봤다.
HTML 코딩을 안 한 지 오래되어서 이런 간단한 페이지를 만드는 데에도 2시간이나 소모하였다.
디자인 감각의 부족으로(대부분은 귀차니즘에서 비롯한 것이긴 하다) 인해 이런 조촐한 웹페이지가 남았다.
jekyll를 소개받기도 했으나 택하지 않았다. 세련된 디자인이 내가 지향하는 점과 달랐기 때문이다.
절대로 루비를 깔기 싫어서 그런 게 아니다! 당분간은 이 디자인 그대로 유지할 듯하다.
		</p>

		<p>
1대1 대결 게임을 만들고 있다. 전투 방식은 턴제로 이루어지는데 이는 마치 포켓몬을 방불케 한다.
물론 포켓몬보다 훨씬 조잡하기 때문에 많은 기능은 없다.
<a href="ba_log.txt">전투 기록</a>을 살펴보면 알 수 있듯이 만족할 만한 수준이 절대 아니다.
한 대를 치면 무조건 한 대를 맞아야 하는 합리를 빙자한 부조리, 메이아 루아 지 꼼빠쑤같은 고급 카라테
스킬의 부재 등으로 인해 목숨을 건 이쿠사 배틀이 한낱 핑퐁놀음으로 격하됐다.
하이쿠를 읊는 장면도 실제 그윽한 명구를 제대로 살리지 못했다. 게임 개발은 역시 만만히 볼 분야가 아니다.
		</p>

		<br>

		<h2>2024/10/12</h2>
		<p>
C언어에서 알면 좋은 스킬을 연습하기 위한 <a href="https://github.com/YesYesBike/train"> 게임</a>
을 개발했다. 16진수 숫자 하나를 보고 2진수를 알아맞히거나 그 반대인 식이다.
개발 과정에서 가장 큰 난관에 부딪치게 했던 것은 문자 입력이었다.
예전에 C언어를 배울 때에도 이 문제로 골머리를 썩힌 적이 있었다. 그렇지만 오늘에서야 일종의 깨달음을 얻었다.
C언어에서 문자 입력을 어렵게 하는 원인은 두 가지이다. 하나는 입력 버퍼, 다른 하나는 EOF이다.
입력 버퍼를 비워야 다음 작업에 지장이 없다. 그러기 위해서는 while문에 getchar()을 쓰면 된다.
EOF는 특수한 경우에 속하기 때문에 따로 예외적인 처리를 해줘야 한다.
EOF를 입력하면 그 뒤로는 표준 입출력을 이용할 수 없다.
그렇기 때문에 이 프로그램에서는 EOF를 입력하면 종료되게끔 하였다.
		</p>

		<p>
위 게임은 아직 16진수 퀴즈밖에 없지만 앞으로 연산자 우선순위, 2의 제곱수 같은 기능도 추가할 예정이다.
아직 시간이 충분하니 오늘 안에 추가할 수도 있겠으나 다른 할 일이 있어서 못할 수도 있다.
		</p>

		<p>
grep, sed, awk에 대한 잡설: 이 세 프로그램은 UNIX 세계에서 유명한 텍스트 처리 도구이다.
grep은 패턴이 일치하는 줄을 출력하고 sed는 입력된 문자열을 한 줄마다 조작하고
awk는 제어문도 지원하는 종합적인 스크립트 언어이다.
위 셋은 모두 stdin으로 입력을 받아 stdout으로 내보낼 수 있어 온갖 상황에서 쉘스크립트에 갖다 붙일 수 있다.
각 프로그램 모두 간단하면서도(awk는 좀 더 복합적이다) 강력하지만
상황에 따라서 적절한 도구를 택해야 더 빠르고 효율적인 스크립트를 짤 수 있다.
		</p>

		<p>
결론부터 말하자면 셋 중에 하나를 쓰고자 할 때 grep, sed, awk 순으로 고려해봐야 한다.
grep은 패턴에 맞는 문자열을 출력하는 것 하나에 있어서 타의 추종을 불허한다
(솔직히 그 정도까지는 아니지만 grep의 명성을 앞지를 프로그램이 과연 어디에 있을까).
sed는 ed라는 고대 텍스트 에디터를 non-interactive하게 구현하도록 설계되었기 때문에 할 수 있는 게 더 많다.
sed의 가장 핵심적인 기능은 역시 문자열 치환에 있다.
tr의 문자 치환 능력은 매우 뛰어나지만 문자열 처리는 안 된다. s/old/new/는 sed의 트레이드 마크이다.
awk는 sed가 구현하지 못하는, 열 단위의 편집을 가능하게 한다. 터미널에 엑셀은 없지만 awk는 있다.
(참고로 말하자면 column이라는 열 단위 편집 프로그램이 하나 있다. 텍스트로 이루어진 표를 좌우로 졍렬하고자 할 때 유용하다.)
		</p>

		<p>
필자의 컴퓨터를 기준으로 grep은 150kb, sed는 100kb, awk는 700kb가량 한다.
grep가 sed보다 용량은 크지만 같은 일을 시켰을 때(패턴에 맞는 줄 출력) 더 빠르게 동작했다.
(실험을 잘못 설계했을지도 모르니 언젠가 다시 실험해봐야겠다. 실제 시간은 재보지 않았지만 체감으로는 차이가 났다.)
		</p>

		<br>

		<h2>2024/10/13</h2>
		<p>
grep에 대한 잡설 하나 추가: 어떤 프로그램의 출력을 걸러내고자 할 때 웬만하면 자체 필터를 이용하자.
그래야 명령어도 간결해지고 효율도 좋아진다. 그러려면 그 명령어 자체를 잘 이해하고 있어야 한다.
ps -ely | grep bash보다 ps -lyC bash가 더 낫다. 정규 표현식을 쓸 거면 pgrep이 있다.
결론: 정규 표현식 기능을 이용하지 않을 거면 자체 기능을 활용하자.
		</p>

		<p>
diff 순서: 바꿀 게 먼저, 바뀔 게 나중에. 너무나 헷갈린다.
		</p>

		<p>
인코더, 디코더, 멀티플렉서, 디멀티플렉서:
인코더는 여러 개의 입력(8 == pow(2,3))을 그보다 더 적은 출력(3)으로 전환하는 것.
디코더는 적은 입력(3)을 더 많은 출력(8)으로 내보내는 것. 진리표를 생각하면 <strong>실제</strong> 어렵지 않다.
멀티플렉서는 여러 군데에서 오는 입력 중 하나를 선택하여 출력으로 내보내는 것(조건에 해당하는 추가 입력이 필요함).
디멀티플렉서는 조건을 입력받아 여러 군데 중 하나에 신호를 내보내는 것.
역시 헷갈린다.
		</p>

		<p>
Perl의 특장점: Perl은 사용자가 최소한의 타이핑으로 극상의 효율을 발휘할 수 있게끔 만들어졌다.
Perl에는 수많은 생략 기법이 있다. <a href="10_perl.txt">이 파일</a>에서 알 수 있듯이
변수명 생략, for 도치법, 괄호 생략 등등의 날빌이 먹히는 걸 볼 수 있다.
특히 $_가 정말 유용하다. $_는 반복문에서 배열을 순회할 때 자기 차례에 해당하는 요소의 값과 같다.
즉 다른 언어에서처럼 굳이 i를 사용할 필요가 없다.
게다가 함수에 전달 인자로 $_만 대입할 때 생략할 수도 있다(#6).
덕분에 가독성을 약간 희생하고 다른 언어에서 열심히 타이핑 칠 동안 느긋이 농땡이 피울 수 있다.
Perl의 배열 자체도 매우 강력하고 유연하다. 이에 대해서는 추후에 작성하겠다.
		</p>

		<br>

		<h2>2024/10/14</h2>
		<p>
10월 12일자 일기에서 cut을 깜빡하고 소개하지 않았다. 자기 직전에 졸면서 쓴 탓에 차마 떠올리지 못했다,
라고 하기에는 어제도 못 알아 챘으니 <strong>실제</strong> 내 실력 부족이다.
어제는 diff에 관한 비망록을 적어뒀으나 혼란만 가중하는 듯하다. 그냥 <strong>전후</strong>만 떠올리면 된다.
pgrep과 관련해서도 정정사항이 있다. pgrep은 검색 조건에 맞는 PID를 찾을 수는 있을지언정 ps처럼 종합적인 정보는 표기하지 못한다.
내가 어제 지껄인 소리는 무시하고 그냥 예전대로 쓰면 될 듯하다(정규 표현식을 쓴다면 말이다).
		</p>

		<p>
오랫동안 수학과 연을 끊어왔으나 이제는 더 이상 물러설 수 없게 되었다. 지금이라도 시작하지 않으면 앞으로 영영 돌이킬 수 없다.
전공자가 아니어서 그들만큼 수학의 중요성을 절감하지는 못하고 있지만 수치해석을 공부하고픈 생각이 들었을 때에는 이미 너무 멀어져 있었다.
수치해석을 공부하려면 미분방정식을 풀 줄 알아야 하는데 공학수학을 못 배워서 y' = y나 y'' = -y 같은 기초 정도밖에 못 푼다.
사실 공학수학을 못 배운 것은 핑계고 오래전인 고등학생 시절에 이미 미적분과 연을 끊었었다.
더 놀라운 사실은 선형대수도 모른다는 것이다(사실 배울 기회가 없었다어쩌구저쩌구 변명거리는 많다)!
		</p>
		<p>
그렇다면 왜 이제 와서 하필이면 수치해석을 배우고 싶은 생각이 들었는가?
그 연원은 아주 오래 전으로 거슬러 올라간다.
초등학생 시절 하루를 빌 게이츠처럼 뛰어난 프로그래머가 되는 망상으로 지새웠던 적이 있었다.
어렸을 때부터 컴퓨터를 아주 좋아했고 프로그래밍에도 관심이 있었다.
하지만 뭘 배워야 하고 그런 자료는 어디서 찾는지도 몰랐다.
책을 찾아보려고 해도 뭐가 뭔지도 모르는 상황에서 길을 잃을 수밖에 없었다.
그 어렸던 때에 프로그래밍 책을 몇 권 샀었는데 지금 들어도 현기증을 유발하는 자바, ASP.NET, 안드로이드 개발 관련 도서였다.
결론적으로 거의 읽지도 않고 내버려두다 대청소 때 내다 팔았다.
처음 배웠던 프로그래밍 언어인 자바는 교재와 똑같이 따라 쳤는데도 컴파일 오류를 내뱉어서 헬로 월드조차 만들 수 없었다.
개발 환경은 당연히 윈도우였고 IDE는 이클립스였다. 상상만 해도 구역질이 치밀어 오르는 광경이었다.
이제 와서 회고해보면 뿌리 깊은 자바 혐오에 내 미숙한 실력과 의지 박약 탓도 있는 듯하지만
코드가 그지같이 생긴 건 예전에나 지금이나 변함이 없고 예전에 썼던 작업 환경 그대로 지금 쓰라고 하면 차라리... (이하 생략)
		</p>
		<p>
어쩌고 보면 리눅스가 내 인생 행로를 뒤바꾼 가장 큰 요인이 되지 않았나 싶다.
사실 처음부터 리눅스를 쓰고자 했던 건 아니었다. 애당초 목적은 지금도 애용하는 텍스트 편집기인 Vim을 배우는 것이었다.
그렇다면 왜 Vim을 배우려고 굳이 리눅스까지 깔았는가? 여기에도 일종의 사연이 있다.
비록 프로그래머가 되는 꿈은 내다 버렸지만 여전히 컴퓨터와 가까이 지냈다. 게임이 주목적이긴 했지만.
텍스트를 편집할 때는 notepad++를 썼는데 이게 현존하는 텍스트 편집기 중에서 최고인 줄 알았다.
그러던 와중에 Vim이 우주 최강의 텍스트 편집기라는 말을 어디선가 주워듣게 되었다.
Vim의 기능을 살펴보니 생전 듣도 보도 못한 신세계가 펼쳐진 것이었다.
마우스를 쓰지 않고도 모든 걸 할 수 있다는 말은 내가 오래전부터 지녀오던 갈증을 달래줄 희소식이었다.
당시에 나는 오른손이 마우스와 키보드를 바삐 오가야 하는 처지를 매우 안타깝게 여기고 있었다.
Vim이 그런 나를 구원할 일종의 예언자로 다가왔던 건 그리 이상한 일이 아니다.
그래서 기쁜 마음으로 gVim을 깔고(윈도우니까) 나서 기대는 이내 실망으로 변했다.
Vim은 상당히 강력하지만 기본 설정으로는 제약이 많다.
gVim도 마찬가지여서 기본 설정으로는 글꼴이 너무 작아 거의 보이지 않을 지경이었다(예상했겠지만 종료하는 데에는 별로 애먹지 않았다. 그냥 창을 닫으면 되기 때문이다. 윈도우니까).
문제는 기껏 설정해놔도 껐다 다시 켜면 기본 설정으로 되돌아 간다는 것이었다.
오랜 검색 끝에 .vimrc 파일을 설정해야 함을 깨닫고 여러 설정을 채워넣어 저장했다.
그런데 그 파일을 저장했는데도 여전히 기본 설정 그대로였다.
경로를 잘못 지정했나 하고 C드라이브, D드라이브 가릴 것 없이 .vimrc 파일을 이리저리 옮겨다녀도 그대로였다.
결국 내 첫 Vim 체험기는 실패로 끝나고 말았다.
아무래도 나머지 이야기는 내일 계속해야 할 것 같다.
		</p>

		<br>

		<h2>2024/10/14</h2>
		<p>
Vim을 쓰려는 시도는 좌절되었지만 hjkl만으로 온 세상을 돌아다닐 수 있다는 꿈은 사라지지 않았다.
몇 달 동안은 실패의 쓰라림을 안고서 묵묵히 살아왔다. 그러다가 기나긴 게임 설정 파일을 힘겹게 편집하던 중 다시 Vim을 떠올리게 되었다.
이번에는 유튜브 동영상으로 순서대로 따라올 수 있게끔 하였다. 지난번에는 차마 그럴 생각조차 못했던 것이다.
유튜브에 'vim setup'이라고 검색하고 보니 콧수염을 달고 후드를 뒤집어 쓴 아재 한 명이 눈에 띄었다.
홀린듯이 마우스 커서를 갖다대고(vimium이 뭔지도 몰랐을 시절이었다) 동영상을 틀었다.
프로그래머에게 프로게이머라고 해도 되는지 모르겠지만 그 사람은 <strong>실제</strong> 프로게이머를 방불케 할 만큼 정신없이 화면을 오갔다.
야바이급 해커를 방불케 하는 달인적 와자마에에 실금하여 회복되기까지 꽤 오랜 시간이 걸렸다.
당시에 Vim이 뛰어나다고는 알고 있었으나 이 정도까지인지는 몰랐던 것이었다.
그래서 그런지는 몰라도 영상 길이는 30분가량 되었지만 동영상대로 완전히 기능을 갖추기까지는 30시간으로도 모자랐다.
		</p>

		<p>
이번에도 삽질은 계속되었다. 여전히 윈도우를 벗어나지 못한 채로(마치 Vim처럼) PowerShell에서 최대한 똑같이 하려고 시도하고 있었다.
당시에는 깃헙이 뭔지도 잘 모르고 개발자가 갖추고 있는 상식이 전무하였다.
저 양반이 리눅스를 쓰고 있었는지도 몰랐기 때문에 그대로 따라했다가는 어디선가 문제가 생길 게 뻔했다.
다행히도 꽤 오랫동안 잘 따라갈 수 있었다. 중간중간 :Tutor로 단축키를 익혀가며 동영상 그대로 하려고 고군분투하고 있었다.
그런데 그 '빌어먹을' LSP를 까는 데에서 정신력을 모두 소진하고 말았다.
이제 와서는 별 필요도 없는 기능이었지만 그때는 LSP가 뭔지도 모르고 있었기 때문에 이대로 안 하면 다음 단계로 못 넘어가는 줄 알았다.
결국 수많은 오류 메시지에 가로막히고 말았다. 예전 같으면 그냥 포기했을 테지만 이번에는 달랐다.
오랫동안 월드와이드웹을 수소문한 결과 윈도우에 Neovim을 까는 짓은 그리 현명하지 않다는 결론이 나왔다.
곧바로 리눅스를 깔아야겠다는 생각이 들었다. 믿기지 않겠지만 Vim을 깔려고 리눅스를 까는 일이 벌어진 것이다.
오늘은 여기까지만 쓰고 내일 이어서 쓰겠다.
		</p>
	</body>
</html>
