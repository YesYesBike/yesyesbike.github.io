<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>C, Perl, Linux</title>
	</head>
	<body>
		<h1>"8진수는 Octal이지만 Octover는 10월이다.<br>
			10진수는 Decimal이지만 December는 12월이다." -미상</h1>
		<hr>
		<p><a href="../../index.html">홈으로</a></p>
		<p><a href="../index.html">일기 목록</a></p>
		<p><a href="index.html">일기/2024년</a></p>
		<br>
		<h2>2024/10/11</h2>
		<p>
깃헙 페이지에 홈페이지를 게시하고 나서 메인 페이지를 손봤다.
HTML 코딩을 안 한 지 오래되어서 이런 간단한 페이지를 만드는 데에도 2시간이나 소모하였다.
디자인 감각의 부족으로(대부분은 귀차니즘에서 비롯한 것이긴 하다) 인해 이런 조촐한 웹페이지가 남았다.
jekyll를 소개받기도 했으나 택하지 않았다. 세련된 디자인이 내가 지향하는 점과 달랐기 때문이다.
절대로 루비를 깔기 싫어서 그런 게 아니다! 당분간은 이 디자인 그대로 유지할 듯하다.
		</p>

		<p>
1대1 대결 게임을 만들고 있다. 전투 방식은 턴제로 이루어지는데 이는 마치 포켓몬을 방불케 한다.
물론 포켓몬보다 훨씬 조잡하기 때문에 많은 기능은 없다.
<a href="ba_log.txt">전투 기록</a>을 살펴보면 알 수 있듯이 만족할 만한 수준이 절대 아니다.
한 대를 치면 무조건 한 대를 맞아야 하는 합리를 빙자한 부조리, 메이아 루아 지 꼼빠쑤같은 고급 카라테
스킬의 부재 등으로 인해 목숨을 건 이쿠사 배틀이 한낱 핑퐁놀음으로 격하됐다.
하이쿠를 읊는 장면도 실제 그윽한 명구를 제대로 살리지 못했다. 게임 개발은 역시 만만히 볼 분야가 아니다.
		</p>

		<br>

		<h2>2024/10/12</h2>
		<p>
C언어에서 알면 좋은 스킬을 연습하기 위한 <a href="https://github.com/YesYesBike/train"> 게임</a>
을 개발했다. 16진수 숫자 하나를 보고 2진수를 알아맞히거나 그 반대인 식이다.
개발 과정에서 가장 큰 난관에 부딪치게 했던 것은 문자 입력이었다.
예전에 C언어를 배울 때에도 이 문제로 골머리를 썩힌 적이 있었다. 그렇지만 오늘에서야 일종의 깨달음을 얻었다.
C언어에서 문자 입력을 어렵게 하는 원인은 두 가지이다. 하나는 입력 버퍼, 다른 하나는 EOF이다.
입력 버퍼를 비워야 다음 작업에 지장이 없다. 그러기 위해서는 while문에 getchar()을 쓰면 된다.
EOF는 특수한 경우에 속하기 때문에 따로 예외적인 처리를 해줘야 한다.
EOF를 입력하면 그 뒤로는 표준 입출력을 이용할 수 없다.
그렇기 때문에 이 프로그램에서는 EOF를 입력하면 종료되게끔 하였다.
		</p>

		<p>
위 게임은 아직 16진수 퀴즈밖에 없지만 앞으로 연산자 우선순위, 2의 제곱수 같은 기능도 추가할 예정이다.
아직 시간이 충분하니 오늘 안에 추가할 수도 있겠으나 다른 할 일이 있어서 못할 수도 있다.
		</p>

		<p>
grep, sed, awk에 대한 잡설: 이 세 프로그램은 UNIX 세계에서 유명한 텍스트 처리 도구이다.
grep은 패턴이 일치하는 줄을 출력하고 sed는 입력된 문자열을 한 줄마다 조작하고
awk는 제어문도 지원하는 종합적인 스크립트 언어이다.
위 셋은 모두 stdin으로 입력을 받아 stdout으로 내보낼 수 있어 온갖 상황에서 쉘스크립트에 갖다 붙일 수 있다.
각 프로그램 모두 간단하면서도(awk는 좀 더 복합적이다) 강력하지만
상황에 따라서 적절한 도구를 택해야 더 빠르고 효율적인 스크립트를 짤 수 있다.
		</p>

		<p>
결론부터 말하자면 셋 중에 하나를 쓰고자 할 때 grep, sed, awk 순으로 고려해봐야 한다.
grep은 패턴에 맞는 문자열을 출력하는 것 하나에 있어서 타의 추종을 불허한다
(솔직히 그 정도까지는 아니지만 grep의 명성을 앞지를 프로그램이 과연 어디에 있을까).
sed는 ed라는 고대 텍스트 에디터를 non-interactive하게 구현하도록 설계되었기 때문에 할 수 있는 게 더 많다.
sed의 가장 핵심적인 기능은 역시 문자열 치환에 있다.
tr의 문자 치환 능력은 매우 뛰어나지만 문자열 처리는 안 된다. s/old/new/는 sed의 트레이드 마크이다.
awk는 sed가 구현하지 못하는, 열 단위의 편집을 가능하게 한다. 터미널에 엑셀은 없지만 awk는 있다.
(참고로 말하자면 column이라는 열 단위 편집 프로그램이 하나 있다. 텍스트로 이루어진 표를 좌우로 졍렬하고자 할 때 유용하다.)
		</p>

		<p>
필자의 컴퓨터를 기준으로 grep은 150kb, sed는 100kb, awk는 700kb가량 한다.
grep가 sed보다 용량은 크지만 같은 일을 시켰을 때(패턴에 맞는 줄 출력) 더 빠르게 동작했다.
(실험을 잘못 설계했을지도 모르니 언젠가 다시 실험해봐야겠다. 실제 시간은 재보지 않았지만 체감으로는 차이가 났다.)
		</p>

		<br>

		<h2>2024/10/13</h2>
		<p>
grep에 대한 잡설 하나 추가: 어떤 프로그램의 출력을 걸러내고자 할 때 웬만하면 자체 필터를 이용하자.
그래야 명령어도 간결해지고 효율도 좋아진다. 그러려면 그 명령어 자체를 잘 이해하고 있어야 한다.
ps -ely | grep bash보다 ps -lyC bash가 더 낫다. 정규 표현식을 쓸 거면 pgrep이 있다.
결론: 정규 표현식 기능을 이용하지 않을 거면 자체 기능을 활용하자.
		</p>

		<p>
diff 순서: 바꿀 게 먼저, 바뀔 게 나중에. 너무나 헷갈린다.
		</p>

		<p>
인코더, 디코더, 멀티플렉서, 디멀티플렉서:
인코더는 여러 개의 입력(8 == pow(2,3))을 그보다 더 적은 출력(3)으로 전환하는 것.
디코더는 적은 입력(3)을 더 많은 출력(8)으로 내보내는 것. 진리표를 생각하면 <strong>실제</strong> 어렵지 않다.
멀티플렉서는 여러 군데에서 오는 입력 중 하나를 선택하여 출력으로 내보내는 것(조건에 해당하는 추가 입력이 필요함).
디멀티플렉서는 조건을 입력받아 여러 군데 중 하나에 신호를 내보내는 것.
역시 헷갈린다.
		</p>

		<p>
Perl의 특장점: Perl은 사용자가 최소한의 타이핑으로 극상의 효율을 발휘할 수 있게끔 만들어졌다.
Perl에는 수많은 생략 기법이 있다. <a href="10_perl.txt">이 파일</a>에서 알 수 있듯이
변수명 생략, for 도치법, 괄호 생략 등등의 날빌이 먹히는 걸 볼 수 있다.
특히 $_가 정말 유용하다. $_는 반복문에서 배열을 순회할 때 자기 차례에 해당하는 요소의 값과 같다.
즉 다른 언어에서처럼 굳이 i를 사용할 필요가 없다.
게다가 함수에 전달 인자로 $_만 대입할 때 생략할 수도 있다(#6).
덕분에 가독성을 약간 희생하고 다른 언어에서 열심히 타이핑 칠 동안 느긋이 농땡이 피울 수 있다.
Perl의 배열 자체도 매우 강력하고 유연하다. 이에 대해서는 추후에 작성하겠다.
		</p>
	</body>
</html>
