<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>C, Perl, Linux</title>
	</head>
	<body>
		<h1>"8진수는 Octal이지만 Octover는 10월이다.<br>
			10진수는 Decimal이지만 December는 12월이다." -미상</h1>
		<hr>
		<p><a href="../../index.html">홈으로</a></p>
		<p><a href="../index.html">일기 목록</a></p>
		<p><a href="index.html">일기/2024년</a></p>
		<br>
		<h2>2024/10/11</h2>
		<p>
깃헙 페이지에 홈페이지를 게시하고 나서 메인 페이지를 손봤다.
HTML 코딩을 안 한 지 오래되어서 이런 간단한 페이지를 만드는 데에도 2시간이나 소모하였다.
디자인 감각의 부족으로(대부분은 귀차니즘에서 비롯한 것이긴 하다) 인해 이런 조촐한 웹페이지가 남았다.
jekyll를 소개받기도 했으나 택하지 않았다. 세련된 디자인이 내가 지향하는 점과 달랐기 때문이다.
절대로 루비를 깔기 싫어서 그런 게 아니다! 당분간은 이 디자인 그대로 유지할 듯하다.
		</p>

		<p>
1대1 대결 게임을 만들고 있다. 전투 방식은 턴제로 이루어지는데 이는 마치 포켓몬을 방불케 한다.
물론 포켓몬보다 훨씬 조잡하기 때문에 많은 기능은 없다.
<a href="ba_log.txt">전투 기록</a>을 살펴보면 알 수 있듯이 만족할 만한 수준이 절대 아니다.
한 대를 치면 무조건 한 대를 맞아야 하는 합리를 빙자한 부조리, 메이아 루아 지 꼼빠쑤같은 고급 카라테
스킬의 부재 등으로 인해 목숨을 건 이쿠사 배틀이 한낱 핑퐁놀음으로 격하됐다.
하이쿠를 읊는 장면도 실제 그윽한 명구를 제대로 살리지 못했다. 게임 개발은 역시 만만히 볼 분야가 아니다.
		</p>

		<br>

		<h2>2024/10/12</h2>
		<p>
C언어에서 알면 좋은 스킬을 연습하기 위한 <a href="https://github.com/YesYesBike/train"> 게임</a>
을 개발했다. 16진수 숫자 하나를 보고 2진수를 알아맞히거나 그 반대인 식이다.
개발 과정에서 가장 큰 난관에 부딪치게 했던 것은 문자 입력이었다.
예전에 C언어를 배울 때에도 이 문제로 골머리를 썩힌 적이 있었다. 그렇지만 오늘에서야 일종의 깨달음을 얻었다.
C언어에서 문자 입력을 어렵게 하는 원인은 두 가지이다. 하나는 입력 버퍼, 다른 하나는 EOF이다.
입력 버퍼를 비워야 다음 작업에 지장이 없다. 그러기 위해서는 while문에 getchar()을 쓰면 된다.
EOF는 특수한 경우에 속하기 때문에 따로 예외적인 처리를 해줘야 한다.
EOF를 입력하면 그 뒤로는 표준 입출력을 이용할 수 없다.
그렇기 때문에 이 프로그램에서는 EOF를 입력하면 종료되게끔 하였다.
		</p>

		<p>
위 게임은 아직 16진수 퀴즈밖에 없지만 앞으로 연산자 우선순위, 2의 제곱수 같은 기능도 추가할 예정이다.
아직 시간이 충분하니 오늘 안에 추가할 수도 있겠으나 다른 할 일이 있어서 못할 수도 있다.
		</p>

		<p>
grep, sed, awk에 대한 잡설: 이 세 프로그램은 UNIX 세계에서 유명한 텍스트 처리 도구이다.
grep은 패턴이 일치하는 줄을 출력하고 sed는 입력된 문자열을 한 줄마다 조작하고
awk는 제어문도 지원하는 종합적인 스크립트 언어이다.
위 셋은 모두 stdin으로 입력을 받아 stdout으로 내보낼 수 있어 온갖 상황에서 쉘스크립트에 갖다 붙일 수 있다.
각 프로그램 모두 간단하면서도(awk는 좀 더 복합적이다) 강력하지만
상황에 따라서 적절한 도구를 택해야 더 빠르고 효율적인 스크립트를 짤 수 있다.
		</p>

		<p>
결론부터 말하자면 셋 중에 하나를 쓰고자 할 때 grep, sed, awk 순으로 고려해봐야 한다.
grep은 패턴에 맞는 문자열을 출력하는 것 하나에 있어서 타의 추종을 불허한다
(솔직히 그 정도까지는 아니지만 grep의 명성을 앞지를 프로그램이 과연 어디에 있을까).
sed는 ed라는 고대 텍스트 에디터를 non-interactive하게 구현하도록 설계되었기 때문에 할 수 있는 게 더 많다.
sed의 가장 핵심적인 기능은 역시 문자열 치환에 있다.
tr의 문자 치환 능력은 매우 뛰어나지만 문자열 처리는 안 된다. s/old/new/는 sed의 트레이드 마크이다.
awk는 sed가 구현하지 못하는, 열 단위의 편집을 가능하게 한다. 터미널에 엑셀은 없지만 awk는 있다.
(참고로 말하자면 column이라는 열 단위 편집 프로그램이 하나 있다. 텍스트로 이루어진 표를 좌우로 졍렬하고자 할 때 유용하다.)
		</p>

		<p>
필자의 컴퓨터를 기준으로 grep은 150kb, sed는 100kb, awk는 700kb가량 한다.
grep가 sed보다 용량은 크지만 같은 일을 시켰을 때(패턴에 맞는 줄 출력) 더 빠르게 동작했다.
(실험을 잘못 설계했을지도 모르니 언젠가 다시 실험해봐야겠다. 실제 시간은 재보지 않았지만 체감으로는 차이가 났다.)
		</p>

		<br>

		<h2>2024/10/13</h2>
		<p>
grep에 대한 잡설 하나 추가: 어떤 프로그램의 출력을 걸러내고자 할 때 웬만하면 자체 필터를 이용하자.
그래야 명령어도 간결해지고 효율도 좋아진다. 그러려면 그 명령어 자체를 잘 이해하고 있어야 한다.
ps -ely | grep bash보다 ps -lyC bash가 더 낫다. 정규 표현식을 쓸 거면 pgrep이 있다.
결론: 정규 표현식 기능을 이용하지 않을 거면 자체 기능을 활용하자.
		</p>

		<p>
diff 순서: 바꿀 게 먼저, 바뀔 게 나중에. 너무나 헷갈린다.
		</p>

		<p>
인코더, 디코더, 멀티플렉서, 디멀티플렉서:
인코더는 여러 개의 입력(8 == pow(2,3))을 그보다 더 적은 출력(3)으로 전환하는 것.
디코더는 적은 입력(3)을 더 많은 출력(8)으로 내보내는 것. 진리표를 생각하면 <strong>실제</strong> 어렵지 않다.
멀티플렉서는 여러 군데에서 오는 입력 중 하나를 선택하여 출력으로 내보내는 것(조건에 해당하는 추가 입력이 필요함).
디멀티플렉서는 조건을 입력받아 여러 군데 중 하나에 신호를 내보내는 것.
역시 헷갈린다.
		</p>

		<p>
Perl의 특장점: Perl은 사용자가 최소한의 타이핑으로 극상의 효율을 발휘할 수 있게끔 만들어졌다.
Perl에는 수많은 생략 기법이 있다. <a href="10_perl.txt">이 파일</a>에서 알 수 있듯이
변수명 생략, for 도치법, 괄호 생략 등등의 날빌이 먹히는 걸 볼 수 있다.
특히 $_가 정말 유용하다. $_는 반복문에서 배열을 순회할 때 자기 차례에 해당하는 요소의 값과 같다.
즉 다른 언어에서처럼 굳이 i를 사용할 필요가 없다.
게다가 함수에 전달 인자로 $_만 대입할 때 생략할 수도 있다(#6).
덕분에 가독성을 약간 희생하고 다른 언어에서 열심히 타이핑 칠 동안 느긋이 농땡이 피울 수 있다.
Perl의 배열 자체도 매우 강력하고 유연하다. 이에 대해서는 추후에 작성하겠다.
		</p>

		<br>

		<h2>2024/10/14</h2>
		<p>
10월 12일자 일기에서 cut을 깜빡하고 소개하지 않았다. 자기 직전에 졸면서 쓴 탓에 차마 떠올리지 못했다,
라고 하기에는 어제도 못 알아 챘으니 <strong>실제</strong> 내 실력 부족이다.
어제는 diff에 관한 비망록을 적어뒀으나 혼란만 가중하는 듯하다. 그냥 <strong>전후</strong>만 떠올리면 된다.
pgrep과 관련해서도 정정사항이 있다. pgrep은 검색 조건에 맞는 PID를 찾을 수는 있을지언정 ps처럼 종합적인 정보는 표기하지 못한다.
내가 어제 지껄인 소리는 무시하고 그냥 예전대로 쓰면 될 듯하다(정규 표현식을 쓴다면 말이다).
		</p>

		<p>
오랫동안 수학과 연을 끊어왔으나 이제는 더 이상 물러설 수 없게 되었다. 지금이라도 시작하지 않으면 앞으로 영영 돌이킬 수 없다.
전공자가 아니어서 그들만큼 수학의 중요성을 절감하지는 못하고 있지만 수치해석을 공부하고픈 생각이 들었을 때에는 이미 너무 멀어져 있었다.
수치해석을 공부하려면 미분방정식을 풀 줄 알아야 하는데 공학수학을 못 배워서 y' = y나 y'' = -y 같은 기초 정도밖에 못 푼다.
사실 공학수학을 못 배운 것은 핑계고 오래전인 고등학생 시절에 이미 미적분과 연을 끊었었다.
더 놀라운 사실은 선형대수도 모른다는 것이다(사실 배울 기회가 없었다어쩌구저쩌구 변명거리는 많다)!
		</p>
		<p>
그렇다면 왜 이제 와서 하필이면 수치해석을 배우고 싶은 생각이 들었는가?
그 연원은 아주 오래 전으로 거슬러 올라간다.
초등학생 시절 하루를 빌 게이츠처럼 뛰어난 프로그래머가 되는 망상으로 지새웠던 적이 있었다.
어렸을 때부터 컴퓨터를 아주 좋아했고 프로그래밍에도 관심이 있었다.
하지만 뭘 배워야 하고 그런 자료는 어디서 찾는지도 몰랐다.
책을 찾아보려고 해도 뭐가 뭔지도 모르는 상황에서 길을 잃을 수밖에 없었다.
그 어렸던 때에 프로그래밍 책을 몇 권 샀었는데 지금 들어도 현기증을 유발하는 자바, ASP.NET, 안드로이드 개발 관련 도서였다.
결론적으로 거의 읽지도 않고 내버려두다 대청소 때 내다 팔았다.
처음 배웠던 프로그래밍 언어인 자바는 교재와 똑같이 따라 쳤는데도 컴파일 오류를 내뱉어서 헬로 월드조차 만들 수 없었다.
개발 환경은 당연히 윈도우였고 IDE는 이클립스였다. 상상만 해도 구역질이 치밀어 오르는 광경이었다.
이제 와서 회고해보면 뿌리 깊은 자바 혐오에 내 미숙한 실력과 의지 박약 탓도 있는 듯하지만
코드가 그지같이 생긴 건 예전에나 지금이나 변함이 없고 예전에 썼던 작업 환경 그대로 지금 쓰라고 하면 차라리... (이하 생략)
		</p>
		<p>
어쩌고 보면 리눅스가 내 인생 행로를 뒤바꾼 가장 큰 요인이 되지 않았나 싶다.
사실 처음부터 리눅스를 쓰고자 했던 건 아니었다. 애당초 목적은 지금도 애용하는 텍스트 편집기인 Vim을 배우는 것이었다.
그렇다면 왜 Vim을 배우려고 굳이 리눅스까지 깔았는가? 여기에도 일종의 사연이 있다.
비록 프로그래머가 되는 꿈은 내다 버렸지만 여전히 컴퓨터와 가까이 지냈다. 게임이 주목적이긴 했지만.
텍스트를 편집할 때는 notepad++를 썼는데 이게 현존하는 텍스트 편집기 중에서 최고인 줄 알았다.
그러던 와중에 Vim이 우주 최강의 텍스트 편집기라는 말을 어디선가 주워듣게 되었다.
Vim의 기능을 살펴보니 생전 듣도 보도 못한 신세계가 펼쳐진 것이었다.
마우스를 쓰지 않고도 모든 걸 할 수 있다는 말은 내가 오래전부터 지녀오던 갈증을 달래줄 희소식이었다.
당시에 나는 오른손이 마우스와 키보드를 바삐 오가야 하는 처지를 매우 안타깝게 여기고 있었다.
Vim이 그런 나를 구원할 일종의 예언자로 다가왔던 건 그리 이상한 일이 아니다.
그래서 기쁜 마음으로 gVim을 깔고(윈도우니까) 나서 기대는 이내 실망으로 변했다.
Vim은 상당히 강력하지만 기본 설정으로는 제약이 많다.
gVim도 마찬가지여서 기본 설정으로는 글꼴이 너무 작아 거의 보이지 않을 지경이었다(예상했겠지만 종료하는 데에는 별로 애먹지 않았다. 그냥 창을 닫으면 되기 때문이다. 윈도우니까).
문제는 기껏 설정해놔도 껐다 다시 켜면 기본 설정으로 되돌아 간다는 것이었다.
오랜 검색 끝에 .vimrc 파일을 설정해야 함을 깨닫고 여러 설정을 채워넣어 저장했다.
그런데 그 파일을 저장했는데도 여전히 기본 설정 그대로였다.
경로를 잘못 지정했나 하고 C드라이브, D드라이브 가릴 것 없이 .vimrc 파일을 이리저리 옮겨다녀도 그대로였다.
결국 내 첫 Vim 체험기는 실패로 끝나고 말았다.
아무래도 나머지 이야기는 내일 계속해야 할 것 같다.
		</p>

		<br>

		<h2>2024/10/15</h2>
		<p>
Vim을 쓰려는 시도는 좌절되었지만 hjkl만으로 온 세상을 돌아다닐 수 있다는 꿈은 사라지지 않았다.
몇 달 동안은 실패의 쓰라림을 안고서 묵묵히 살아왔다. 그러다가 기나긴 게임 설정 파일을 힘겹게 편집하던 중 다시 Vim을 떠올리게 되었다.
이번에는 유튜브 동영상으로 순서대로 따라올 수 있게끔 하였다. 지난번에는 차마 그럴 생각조차 못했던 것이다.
유튜브에 'vim setup'이라고 검색하고 보니 콧수염을 달고 후드를 뒤집어 쓴 아재 한 명이 눈에 띄었다.
홀린듯이 마우스 커서를 갖다대고(vimium이 뭔지도 몰랐을 시절이었다) 동영상을 틀었다.
프로그래머에게 프로게이머라고 해도 되는지 모르겠지만 그 사람은 <strong>실제</strong> 프로게이머를 방불케 할 만큼 정신없이 화면을 오갔다.
야바이급 해커를 방불케 하는 달인적 와자마에에 실금하여 회복되기까지 꽤 오랜 시간이 걸렸다.
당시에 Vim이 뛰어나다고는 알고 있었으나 이 정도까지인지는 몰랐던 것이었다.
그래서 그런지는 몰라도 영상 길이는 30분가량 되었지만 동영상대로 완전히 기능을 갖추기까지는 30시간으로도 모자랐다.
		</p>

		<p>
이번에도 삽질은 계속되었다. 여전히 윈도우를 벗어나지 못한 채로(마치 Vim처럼) PowerShell에서 최대한 똑같이 하려고 시도하고 있었다.
당시에는 깃헙이 뭔지도 잘 모르고 개발자가 갖추고 있는 상식이 전무하였다.
저 양반이 리눅스를 쓰고 있었는지도 몰랐기 때문에 그대로 따라했다가는 어디선가 문제가 생길 게 뻔했다.
다행히도 꽤 오랫동안 잘 따라갈 수 있었다. 중간중간 :Tutor로 단축키를 익혀가며 동영상 그대로 하려고 고군분투하고 있었다.
그런데 그 '빌어먹을' LSP를 까는 데에서 정신력을 모두 소진하고 말았다.
이제 와서는 별 필요도 없는 기능이었지만 그때는 LSP가 뭔지도 모르고 있었기 때문에 이대로 안 하면 다음 단계로 못 넘어가는 줄 알았다.
결국 수많은 오류 메시지에 가로막히고 말았다. 예전 같으면 그냥 포기했을 테지만 이번에는 달랐다.
오랫동안 월드와이드웹을 수소문한 결과 윈도우에 Neovim을 까는 짓은 그리 현명하지 않다는 결론이 나왔다.
곧바로 리눅스를 깔아야겠다는 생각이 들었다. 믿기지 않겠지만 Vim을 깔려고 리눅스를 까는 일이 벌어진 것이다.
오늘은 여기까지만 쓰고 내일 이어서 쓰겠다.
		</p>
		
		<br>

		<h2>2024/10/16</h2>
		<p>
이제야 리눅스를 왜 깔게 되었는지 설명이 된 듯하다. 하지만 아직 이야기는 더 남아있다.
리눅스를 깔기로 결심은 했지만 시작은 상당히 미약했다. 바로 가상머신에다 설치한 것이었다.
그때는 WSL이 있는지도 몰랐다. 그렇지만 그걸 알았더라면 지금의 나는 없었을 테니 <strong>실제</strong> 새옹호스다.
듀얼부팅은 너무나 큰 모험이어서 쉽고 안전하게 잘 알려진 방식대로 설치하였다.
즉 우분투를 깔게 된 것이었다. 웹 검색에서 나오는 게 거의 다 우분투밖에 없었으니 놀랄 일은 아니다.
설치 과정은 크게 어렵지 않았다. 그냥 버튼 몇 개 누르고 기다리면 끝이었다.
다만 그 기다림이 내게는 크나큰 고난이었다. 설치하는 데에 1시간, 업데이트에 2시간이 걸려서 리눅스 설치만 했는데도 하루가 다 가버렸다.
물론 가상머신 위에서 돌아간 탓이 크지만 최소 설정으로 깔았는데도 쓰지도 않을 수많은 프로그램을 업데이트하느라 시간을 낭비하는 게 너무나 못미더웠다.
		</p>
		<p>
드디어 오랜 기다림 끝에 진짜 목표인 Vim을 설정할 수 있게 되었다, 라고 말할 수 없어서 너무나 통탄스럽다.
지금에야 너무나 편안하고 GUI보다 더 안락한 터미널이지만 당시에는 디렉토리를 오가기는커녕 종료 명령어조차 몰랐다.
그나마 다행히도 검색만 하면 원하는 명령어를 찾을 수 있었다. 그래서 어찌저찌 quit인지 exit인지 혼동하면서 차츰 명령어를 익혔다.
그때 찾아봤던 수많은 유튜브 영상들에 아직도 빚을 지고 있다. 하는 그대로 따라 치니 별 문제 없이 따라갈 수 있었다.
여하튼 그와 동시에 Vim 설정도 따라갈 수 있었다. 확실히 UNIX 환경이 Vim에 더 잘 맞는 게 느껴졌다.
윈도우에서는 부분적으로 동영상과는 다르게 설정해야 했던 반면에 리눅스에서는 그냥 따라만 하면 저절로 되었다.
오랫동안 정신을 갉아먹던 LSP도 여기서는 오류를 내뱉지 않고 일단 깔렸다(일단은 말이다).
우분투 업데이트 시간 동안의 기다림 끝에 드디어 Vim 설정을 완료했다.
그렇지만 수치해석은 언제쯤에 다시 이야기 할 수 있을지 모르겠다.
적어도 오늘은 아닌 게 확실하다.
		</p>
		
		<br>

		<h2>2024/10/17</h2>
		<p>
한영타 변환기에 활성화/비활성화 토글 기능을 추가했다. $키를 인식하여 그때마다 한글 변환 여부를 바꾼다.
이로써 그동안 일기를 쓰면서 나를 귀찮게 했던 일에서 벗어날 수 있게 되었다.
이 일기도 한영타 변환기로 작성하고 있는데 알파벳을 작성할 때마다 따로 일일이 작성해야 해서 번거로웠다.
이제는 프로그램을 종료하지 않고도 알파벳을 쓸 수 있게 되었다.
		</p>

		<p>
다시 옛날 이야기로 돌아가보겠다. 드디어 Vim 설정을 끝내고 나니 그에 맞는 작업환경이 필요했다.
이제 와서 새삼 느끼지만 효율을 올리기 위해 Vim을 배운다면 본래 목적은 뒷전이 되고 오로지 생산성을 위한 수단만을 강구하게 되는 듯하다.
그렇지만 내 본래 목적은 Vim이었기 때문에 전혀 상관이 없었다.
Vim의 곁가지로 배우던 리눅스였지만 공부하다 보니 윈도우와는 전혀 다른 신세계를 느끼게 되었다.
터미널 환경은 잘 모르는 사람에게는 무미건조한 황무지로 보이겠지만 그 강력함을 아는 사람에게는 거기서 필요한 모든 것을 얻을 수 있다.
나 또한 예전에는 터미널은 뭔가 많이 부족한 걸로 여겼다. 하지만 조금 써보니 다른 모든 응용프로그램이 무색할 만큼 효과적이었다.
GUI에서는 매우 힘든 일괄 처리나 자동화 작업도 명령어 몇 개로 해결할 수 있다.
리눅스 명령어를 차츰 익히면서 그래픽 환경에서는 느끼기 힘든 텍스트를 가지고 노는 재미를 느끼게 되었다.
Vim을 익히면서 Vim이 이런 텍스트 위주의 환경과 잘 맞는 걸 깨달았다.
예를 들어 Vim은 :! 명령어로 외부 유틸리티를 호출해서 그 출력을 입력할 수 있다. VS 뭐시기에서는 이런 걸 얼마나 잘 할 수 있는지 모르겠다.
사실 뭐시기 code를 써보지 않은 건 아니다. 하지만 이건 주제에서 벗어나는 얘기다.
		</p>

		<p>
아무튼 가상머신+우분투 조합에도 굴하지 않고 터미널에서 거주하던 도중 한 가지 문제가 생겼다.
실수로 계정을 비활성화해서 로그인을 할 수 없게 된 것이었다.
이제 와서는 코웃음을 칠 일이지만 그때는 그야말로 마른 하늘에 날벼락이었다.
우분투를 써본 사람은 다 알겠지만 최초 로그인을 할 때에는 루트 계정으로 로그인할 수 없다.
로그인할 수 있는 계정이 사용자 계정밖에 없는 상태에서 그걸 비활성화하니 로그인할 방법이 없었다.
지금 같으면 부팅 디스크로 복구하겠지만 당시에는 전혀 상상도 못했다.
그래서 눈물을 머금고 처음부터 다시 설치해야 했다.
.dotfile도 몰랐으니 했던 짓을 똑같이 반복해야 한 건 말할 필요도 없었으나 이미 말해버렸다.
전화위복이라고 했던가. 이참에 우분투가 아닌 다른 리눅스 배포판을 쓰고 싶다는 생각이 들었다.
리눅스를 배우면서 다른 배포판의 존재도 알게 된 것이었다.
그중 몇 가지가 후보로 오르게 되었다. 그게 뭔지는 내일 말하겠다.
		</p>

		<br>

		<h2>2024/10/21</h2>
		<p>
요 근래에 여러 일들이 겹처 일기를 쓸 시간이 나질 않았다. 사실 시간은 있었으나 몸이 피곤하였다.
사실 피곤했던 것도 다 이유가 있다. 바로 <a href="https://github.com/YesYesBike/hanoi">하노이탑 게임</a>을 만드느라 일기를 쓰지 못했던 것이다.
만들기 전에는 깨닫지 못했으나 이 게임은 매우 심각할 정도로 중독성이 있었다.
밤낮을 잊고 탑을 옮기느라 도무지 일기를 쓸 틈이 나지 않았던 것이다.
오늘은 간신히 그 늪에서 빠져나와 잠깐 틈을 내어 일기를 작성하겠다.
		</p>

		<p>
리눅스를 새로 까는 여정을 앞두고 우분투를 대신할 배포판을 물색하고 있었다.
내가 원하는 것은 다음과 같았다. 1)GUI 없는 것. 이미 윈도우로 충분하다. 2)쓸데없는 프로그램이 적은 것.
이를 중점으로 Debian, Arch, Gentoo 이 세 가지 배포판을 최종 후보로 정했다.
셋 다 쟁쟁한 경쟁을 펼쳤지만 최종적으로 Arch를 택했다.
Gentoo는 가상머신 위에서 컴파일 할 여력이 없었기 때문에 기각했다.
Debian은 상당히 괜찮은 대안이었으나 Arch의 후술할 강점 때문에 떨어트렸다.
Arch는 처음부터 끝까지 사용자의 손을 거쳐야 하는 DIY 그 자체의 배포판이다. 설치, 유지보수 난이도가 상당하지만 보람도 크다.
우연인지는 몰라도 이런 철학은 Vim과도 일맥상통한다. 배우기는 어렵지만 익숙해지면 그만한 게 없는 것. 이 때문에 Arch를 골랐다.
그때는 리눅스 뽕에 취한 나머지 잘못된 길로 들어서는 게 아닌가 싶은 생각도 있었지만 지금 돌아보면 전혀 쓸데없는 걱정이었다.
		</p>
		
		<p>
리눅스라고는 우분투만 고작 며칠 돌려본 게 전부인 내게 Arch는 너무나 가파른 능선이었다.
Archwiki에서 설치 가이드를 제공했지만 초심자인 내게는 너무나 어려웠다.
가이드에서는 (당연히) 네이티브 머신에서 설치할 것을 전제로 진행했기 때문에 부팅 환경 확인(UEFI인지 BIOS인지)과 디스크 포맷 관련 내용을 앞에다 놓았다.
가상머신에서 루트/홈/스왑 파티션을 나누는 게 헛짓거리인 줄도 모르고 fdisk로 한참 동안 삽질을 했다.
그 뒤에는 어떤 파티션을 ext4로 포맷해야 하는지 어떤 게 스왑 파티션인지 일일이 기억해야 해서 골치를 썩혔다. 사실 이는 Arch Linux 설치만 5번 해본 지금도 번거로운 작업이다.
그렇게 힘겹게 포맷한 파티션을 또 일일이 마운트했다(중간에 부트로더 관련해서 몇 시간 날렸다). 이제 겨우 설치 준비를 끝냈다.
이어서 더 쓰고싶지만 잠이 쏟아지는 관계로 오늘은 여기서 줄이겠다.
		</p>

		<br>

		<h2>2024/10/23</h2>
		<p>
Arch 리눅스를 설치하는 과정은 우분투에 비해서 무지막지하게 험난했다.
이전에 기술한 과정은 모두 설치를 준비하는 전초 작업에 불과했다.
파티션 할당 작업이 원래 손이 많이 가는 일임은 분명하지만 가상머신에서까지 그럴 필요는 전혀 없었다.
드디어 모든 준비가 끝나고 pacstrap의 시간이 왔다. 이제서야 Arch를 깔 수 있었다.
Arch의 가장 강한 점이 여기서 드러난다. 바로 자기가 원하는 패키지<strong>만</strong> 깔 수 있는 것이다.
base, linux, linux-firmware 패키지만 깔아도 전혀 이의를 제기하지 않는다.
물론 이것만 깔아서는 인터넷 연결도 안 되고 문서 편집도 못해서 이도저도 못한다.
맨 처음 깔았을 때 NetworkManager를 빼먹었다가(설치할 때는 인터넷 문제가 없어서 안 깔아도 되는 줄 알았다) 피를 봤었다.
pacstrap 이후에 genfstab까지 마치고 나면(다행히도 이건 안 빼먹었다) 설치는 끝났다고 보면 된다.
		</p>

		<p>
설치는 끝이 났지만 이제는 내게 맞는 환경을 설정해야 했다.
arch-chroot를 입력하고 나니 많이 휑해진 게 체감되었다.
이전까지는 기능이 다양한 zsh에서 그나마 편하게 작업할 수 있었지만 이제는 자동완성도 없이(bash-autocompletion를 알기까지 한참이 걸렸다) 앞으로를 헤쳐나가야 했다.
자동완성이 있고 없고의 차이는 직접 경험하지 않으면 알 수 없다.
탭 키를 누르면 여덟 칸이 그대로 띄어지는 그 느낌은 절대 잊을 수 없다.
그렇게 모든 명령어를 전부 직접 입력해야 하는 고난의 행군이 시작되었다.
		</p>

		<br>

		<h2>2024/10/25</h2>
		<p>
그제서야 깨달은 사실이지만 가상머신에서는 네트워크 속도가 제대로 나지 않는다.
적어도 MB/s 단위는 나와야 하는데 200~300KB/s 대에서 멈춰있으니 뭘 하든 한참을 기다려야 했다.
원래 이런가 하고 참고 있었으나 우연히 다른 사람의 영상을 찾아보니 pacman 업데이트 속도가 나랑은 비교가 되지 않을 정도로 휙휙 지나가는 것이었다.
가상머신에서 아무리 날고 기어봐야 Native Machine만큼의 효율은 발휘할 수 없음을 절감하였다.
이제는 더 이상 가상머신에서 머무르는 게 불가능한 것을 깨달은 것이다.
사실 네트워크 말고도 불편한 점은 많았다. 예를 들어 가상머신과 웹 브라우저를 오갈 때마다 가상머신 이스케이프 키를 추가로 눌러야 하는 게 심히 번거로웠다.
가상머신 내에서 브라우저를 쓰려고 했으나 심히 느려서 단념할 수밖에 없었다.
가상머신을 쓰면서 깨달은 점이 하나 더 있다. 바로 운영체제가 뭐건 간에 데스크탑 이용자는 웹브라우저를 제일 우선시 한다는 사실을 말이다.
호스트 머신에서는 웹브라우저 말고는 foreground에서 구동하는 프로그램이 없었다.
그러던 차에 이참에 리눅스를 직접 까는 게 좋겠다는 생각이 들었던 것이다.
		</p>

		<p>
떠날 준비를 위해 USB에다 부팅 이미지를 굽고는 휴대폰에 Arch 설치 안내 페이지를 띄워놓았다.
설치 공간 확보를 위해 디스크 정리도 하였다. C드라이브에서 50GB, D드라이브에서 500GB 가량을 분리했다.
가상머신에서 설치한 게 불과 며칠 전 일이었기 때문에 하던 대로 똑같이 따라만 하면 되는 줄 알았다.
그렇게 부팅 디스크를 꽂고 재부팅을 하였으나 부팅 디스크로 부팅이 안 되고 윈도우로 넘어갔다.
한참을 껐다 켰다 하며 삽질하면서 Secure Boot 옵션을 비활성화해야 함을 깨달았다.
Secure Boot를 비활성화하고 재부팅했으나 여전히 그대로였다.
알고 보니 부팅 순서가 맨끝으로 밀려나 있어서 수동으로 순서를 조정해야 했었다. 그제서야 Arch 설치 디스크로 진입할 수 있었다.
여기서 전술한 설치 과정을 똑같이 기술하는 것은 지면 낭비이자 시간 낭비일 것이다. 그러나 여기서 몇 가지 차이점을 쓰고자 한다.
먼저 듀얼부팅 문제이다. 설치 가이드에 쓰여있는 그대로 해도 도무지 윈도우 부트 매니저를 인식하지 못했다.
os-prober를 활성화해도 똑같았다. 이 때문에 한참 동안 BIOS에서 직접 GRUB과 윈도우 부트로더의 순서를 지정해야 했다.
나중에서야 grub-mkconfig 스크립트 자체를 고쳐서 해결했다.
그 다음으로 그래픽 환경 설정이었다. Arch에서는 자체적인 그래픽 환경을 제공하지 않아서 유저가 직접 설정해야 한다.
Arch를 설치하면서 여차저차 알아본 바로는 Gnome,KDE,xfce,MATE 같은 desktop environment와 i3,Awesome,dwm 같은 window manager가 있었다.
Desktop Environment는 Window Manager보다 기능은 많지만 더 무겁다.
Window Manager 중에서도 다양한 기능을 가진 i3,Awesome와 최소한의 기능만 제공하는 dwm 등으로 나뉜다.
내 입맛에는 dwm이 맞을 듯하여 dwm을 골랐다. 지금까지 써본 바로는 전혀 부족한 게 없다.
		</p>
	</body>
</html>
