<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>C, Perl, Linux</title>
	</head>
	<body>
		<h1>"" -미상</h1>
		<hr>
		<p><a href="../../index.html">홈으로</a></p>
		<p><a href="../index.html">일기 목록</a></p>
		<p><a href="index.html">일기/2024년</a></p>
		<p><a href="11.html">&lt;- 11월</a></p>
		<br>
		<h2>2024/12/27</h2>
		<p>
무려 한 달 만에 일기를 쓴다. 이 기간 동안 무슨 일이 있었는지는 기억이 나지 않지만 별 일 없었을 것이다.
단지 일기를 쓰기가 귀찮았을 뿐이지 큰 사고를 겪지는 않았다. 그 증거로 깃허브 커밋 기록을 들 수 있다.
		</p>

		<p>
과연 우리는 무엇을 원하는지 얼마나 잘 알까? 불확실한 요구사항은 프로그래머의 난적이다.
물론 나는 여태껏 오로지 나 자신만을 위해 프로그래밍을 해왔기 때문에 이런 고충에 깊이 공감하지는 못한다.
하지만 기껏 만든 걸 계속 갈아엎는 데에 드는 비용과 고생이 얼마나 막대할지는 짐작할 수 있다.
모든 걸 글로 나타내는 건 불가능하다. 당장 이 글만 하더라도 머릿속에만 머무는 생각이 얼마나 많은지 헤아릴 수 없다.
진정으로 원하는 게 뭔지는 자기가 가장 잘 알겠지만 자신조차 대략적으로밖에 모른다.
		</p>

		<p>
지난 달부터 객체 지향 프로그래밍을 시도해 봤지만 이제는 완전히 내다 버렸다.
목적지가 바로 앞에 있는데도 그걸 빙 돌아서 가야 하는 부조리를 견디기 힘들었다.
구조체에 곧바로 접근해도 될 일을 객체에 해당하는 메서드를 호출해서 이러쿵저러쿵하는 게 너무 비효율적이게 보였다.
상속, 다형성, 솔리드 원칙, 디자인 패턴 등등은 이제 내 프로그래밍 인생에서 다시는 거론하지 않을 것이다.
물론 모듈화나 Interface-Implementation 이원화처럼 유지보수에 있어서 중요한 요소까지 포기한 것은 아니다.
이는 C언어 자체의 기능만으로도 충분히 구현할 수 있기 때문이다.
		</p>

		<p>
비록 C언어가 완벽과는 거리가 멀지만 적어도 코드가 컴퓨터에서 얼마나 거지같이 돌지를
적나라하게 드러낸다는 점에서 겉으로만 순수함을 추구하는 다른 언어(그래 리스프 너 말이야)보다 훨씬 낫다.
얼마 전에는 C++도 시도해봤으나 std::cout &gt;&gt; "Hello World\n" &gt;&gt; std::endl의 쓴 맛을 보고는 다시는 이 언어로 코딩하지 않기로 맹세했다.
문법과 기능에 차이가 적다고 C언어와 C++를 함께 엮는 현실이지만 나는 도무지 이런 C++의 괴랄한 문법을 인정할 수 없다.
UNIX 철학의 정수인 C언어와는 다르게 C++는 마이크로소프트의 영향을 막대하게 받았다.
C++를 마이크로소프트에서 만들었다고 말해도 최소 20프로 정도는 맞을 것이다.
POSIX와 윈도우 API의 대표적인 함수 몇 개만 비교해 보면 C와 C++의 지향점이 어떻게 다른지 충분히 알 수 있다.
C++는 C의 가장 큰 특징인 간결함을 말 그대로 내다버렸다.
		</p>

		<p>
내가 객체지향 프로그래밍을 그만둔 데에는 세 가지 이유가 있다.
하나는 맨 처음에 말한 객체지향 원칙의 비효율성이다.
다른 하나는 OOP 언어 특유의 쓸데없이 긴 코드다.
이제 마지막 이유를 말할 차례다.
객체지향 프로그래밍은 사람에게 친숙한 코드를 짜는 것을 목표로 생겨났다.
만약 이 목표를 이뤘다면 나는 객체지향 프로그래밍을 쉽게 익힐 수 있었을 것이다.
그러나 내게는 이런게 뜬구름만 잡는 허깨비로밖에 보이지 않았다.
아직까지도 is-a와 has-a의 차이점이 뭔지 모르겠다.
스펠링이 다른 건 알겠는데 그것 말고 컴퓨터의 관점에서 뭐가 어떻게 다른지 알 수가 없다.
		</p>

		<p>
C언어도 추상화 수준이 높은 언어이지만 여기서 등장하는 개념들은 상당히 직관적이다(물론 제대로 알려면 끝이 없기는 하다. 예를 들면 statement와 expression의 차이).
언어 자체만 배우면 이해하기 어려운 개념들도 메모리를 떠올리면 이러한 안개는 사라진다.
모든 것은 0과 1로 이루어진 데이터이고 이들은 메모리에 저장된다는 사실만 기억해두면 된다.
변수명은 메모리 주소를 사람이 구별하기 쉽게 하기 위한 표식이다(어쩌면 이게 진정한 객체지향 프로그래밍이 아닐까!).
변수의 type은 해당하는 주소에 있는 값을 어떤 식으로 해석할 것인지 나타낸다.
포인터는 거칠게 말해서 type을 지닌 메모리 주소이다. 포인터의 증감은 이 type을 단위로 하여 이루어진다.
포인터도 포인터가 아닌 값과 동일하게 '값'이기 때문에 메모리에 저장된다.
결국 이 둘은 컴퓨터에게 본질적으로 다른 게 없다. 차이라면 직접 참조냐 간접 참조냐뿐이다.
어셈블리의 관점에서 (지역)변수는 단지 스택 포인터의 값을 조정해 할당된 공간 그 이상도 이하도 아니다.
그리고 그걸 어떻게 다룰지는 프로그래머에게 달렸다.
부동소수점 연산에 써먹든 그걸 역참조해서 Segfault를 내든 컴퓨터는 시키는 대로 따를 뿐이다.
		</p>

		<p>
사람마다 능력이 다르고 좋아하는 게 다르다. 나는 단지 작은 것을 다루더라도 확실히 통제하기를 원한다.
이런 점에서 내게는 저수준의 프로그래밍이 더 적성에 맞는 것 같다.
그래서 앞으로도 꾸준히 컴퓨터 구조론과 운영체제론, 그리고 시스템 프로그래밍을 배워나가겠다.
참고로 현재 밑바닥에서부터 음악을 만드는 프로젝트를 진행중인데 이게 어떻게 될지 아직 모르겠다.
사인파, 사각파, 삼각파 같은 기본적인 파형을 wav 포맷으로 저장하는 건 되는데 이걸로 제대로 된 음악을 만들 수 있을지는 아직 미지수이다.
다음으로 해야할 일은 LPF 같은 주파수 필터를 구현하는 게 될 것 같다.
		</p>
	</body>
</html>
