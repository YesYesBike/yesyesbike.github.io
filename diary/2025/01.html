<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>C, Perl, Linux</title>
	</head>
	<body>
		<h1>"No code is faster than no code." -Merb</h1>
		<hr>
		<p><a href="../../index.html">홈으로</a></p>
		<p><a href="../index.html">일기 목록</a></p>
		<p><a href="index.html">일기/2025년</a></p>
		<p><a href="../2024/12.html">&lt;- 12월</a></p>
		<br>
		<h2>2025/01/01</h2>
		<p>
새해를 맞은 기념으로 일기장 페이지를 새로 옮겼다.
프로그래밍 언어라고 부르면 온갖 사람들에게 욕을 얻어먹는 HTML이지만 이것만으로도 꽤 좋은 웹사이트를 만들 수 있다.
모든 복잡한 프로그램은 작성할 때뿐 아니라 그 뒤에도 커다란 짐이 된다.
마찬가지로 웹사이트도 여러가지 기능을 추가하면 유지보수하기 점점 어려워진다.
		</p>

		<p>
올해의 격언으로 'Deleted Code is Debugged Code'를 골랐다.
이는 소프트웨어 개발에서 절대 변하지 않을 진리 중 하나일 것이다.
어떤 코드를 작성하든 간에 그 순간 복잡성이 생겨나 언젠가는 완전히 통제할 수 없는 영역으로 도달할 것이다.
이는 버그의 원인이 된다. 디버깅 시간이 코드 길이의 제곱으로 증가함을 상기하자.
모든 버그를 확실하게 해결할 수 있는 Silver Bullet이 있다. 바로 코드를 말끔히 지워버리는 것이다.
이로써 책임 소재를 보다 분명하게 할 수 있다. 만약 하드웨어에 문제가 없다면 문제는 사라질 것이다.
		</p>

		<p>
코딩과 글쓰기의 공통점에 대해 생각해보자.
코딩을 할 때 처음에는 별다른 제약 없이 자유롭게 코드를 입력하더라도 괜찮다.
하지만 별 생각 없이 규모를 늘리다 보면 언젠가 대가를 치르게 된다.
코드 전체의 간단함을 유지하려면 그 방법을 떠올릴 수 있을 만큼 운이 좋아야 한다.
만약 그 방법을 모르겠다면 가만히 있는 게 좋다.
		</p>

		<br>

		<h2>2025/01/04</h2>
		<p>
최근에 아주 큰 깨달음을 얻었다. 프로그램에 어떤 기능을 추가하든 간에 그 코드는 성능을 더 나쁘게 할 수밖에 없음을 알았다.
모든 프로그램은 특정한 임무를 가진다. 정확히 계산하기는 어렵지만 할 수 있는 일이 늘어날수록 프로그램의 크기 또한 증가한다.
디렉토리를 생성하는 mkdir, 파일을 삭제하는 rm 등은 보통 한 가지 일만 한다.
awk는 좀 더 많은 일을 할 수 있고 perl은 상상할 수 있는 모든 일을 할 수 있다 카더라.
하나에 특화된 프로그램은 범용성 있는 프로그램보다 더 가볍다
(gawk가 perl보다 파일 크기가 더 큰 걸로 확인되었는데 라이브러리 등의 다른 요인이 있을 테니 넘어가겠다).
		</p>

		<p>
유닉스는 한 가지 일만 잘하는 여러 프로그램을 조합해 수많은 일을 해낼 수 있음을 입증했다.
불행히도 오늘날 존재하는 수많은 프로그램은 이를 그대로 적용하기 어렵다.
특히 사용자와 상호작용하는 프로그램은 독립적인 여러 프로그램으로 분리하기 꽤 힘들다.
텍스트 편집기를 예로 들어보자. 텍스트 편집기의 임무는 텍스트를 편집하는 것이다.
먼저 파일을 열어야 한다. 그러고 나서 글자를 입력한다. 오타를 지운다. 마지막으로 파일을 저장한다.
이 넷을 여러 프로세스에서 나누어 처리할 수 있지만(사실 쉘 하나에서 전부 처리할 수도 있다) 상당히 비효율적이다.
ed조차 하나의 프로세스에서 이를 해결할 수밖에 없었다.
		</p>

		<p>
결국 하나의 프로그램 안에서 여러 서브루틴을 잘게 쪼개는 방식을 택할 수밖에 없다.
비록 이들 각각이 하나의 온전한 프로그램으로 있을 수는 없지만 잘 만들어진다면 다른 프로그램에서도 써먹을 수 있다.
여기서 질문이 있다. 과연 이렇게 프로그램 안에서 구현한 함수가 다른 프로그램에서도 똑같이 쓰일 수 있을까?
할 수만 있다면 그렇게 하는 게 좋다. 실제로 자주 쓰는 함수를 라이브러리에 편입할 수 있다. 그렇지만 이는 일부에 불과하다.
웬만한 함수는 특정한 종류의 데이터를 특정한 방식으로 처리하기 때문에 다른 프로그램에서도 똑같은 형식의 데이터를 똑같이 처리할 필요가 생길 때에야 비로소 이를 재사용할 수 있다.
		</p>

		<p>
Kernighan의 법칙이 있다. 디버깅은 특정 코드를 작성하는 하는 것보다 두 배 더 어렵다는 법칙이다.
자신의 능력을 100% 발휘해서야 겨우 코드를 짠다면 그걸 디버깅하는 것은 법칙에 의해 불가능하다.
이 법칙이 주는 가르침은 여러가지가 있지만 이번에는 글쓰기에 초점을 맞춰보겠다.
자신이 아는 지식을 총동원해서 글을 작성한다면 거기에 있는 오류(자신이 오류임을 알 수 없는 것)가 뭔지 알 수 없다.
즉 외부 자료 없이 오로지 자신의 생각만을 바탕으로 글을 쓴다면 자신의 지식으로 오류를 수정할 수 없다.
글을 쓴 뒤 한참이 지나서야 비로소 자신의 실수나 무지나 오해를 깨닫게 된다.
약 3달 가량 일기를 되돌아보면서 꽤나 많은 곳에서 잘못된 점을 발견했다.
2024년 10월 12일(2일째) 일기에서부터 바로 오류를 발견하였다.
여기서는 EOF를 입력받으면 더 이상 입력을 받을 수 없다고 말했지만 clearerr()로 다시 입력을 받을 수 있게 할 수 있다.
이처럼 예전에 쓴 글에서 무지를 재발견하는 것은 불가피하다.
오류까지는 아니더라도 의견의 변화도 꽤 있었다.
하지만 여기에 일일이 적기에는 이미 시간이 너무 늦었다...
		</p>
	</body>
</html>
